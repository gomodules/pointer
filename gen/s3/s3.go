// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.

// Package s3 provides a client for Amazon Simple Storage Service.
package s3

import (
	"encoding/xml"
	"net/http"
	"time"

	"github.com/stripe/aws-go/aws"
	"github.com/stripe/aws-go/aws/gen/endpoints"
)

import (
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"net/url"
	"strconv"
	"strings"
)

// S3 is a client for Amazon Simple Storage Service.
type S3 struct {
	client *aws.RestClient
}

// New returns a new S3 client.
func New(creds aws.Credentials, region string, client *http.Client) *S3 {
	if client == nil {
		client = http.DefaultClient
	}

	service := "s3"
	endpoint, service, region := endpoints.Lookup("s3", region)

	return &S3{
		client: &aws.RestClient{
			Context: aws.Context{
				Credentials: creds,
				Service:     service,
				Region:      region,
			},
			Client:     client,
			Endpoint:   endpoint,
			APIVersion: "2006-03-01",
		},
	}
}

// AbortMultipartUpload aborts a multipart upload. To verify that all parts
// have been removed, so you don't get charged for the part storage, you
// should call the List Parts operation and ensure the parts list is empty.
func (c *S3) AbortMultipartUpload(req *AbortMultipartUploadRequest) (err error) {
	// NRE

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/{Bucket}/{Key+}"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	if req.Key != nil {
		uri = strings.Replace(uri, "{"+"Key"+"}", *req.Key, -1)
		uri = strings.Replace(uri, "{"+"Key+"+"}", *req.Key, -1)
	}

	q := url.Values{}

	if req.UploadID != nil {
		q.Set("uploadId", *req.UploadID)
	}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("DELETE", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()

	return
}

// CompleteMultipartUpload completes a multipart upload by assembling
// previously uploaded parts.
func (c *S3) CompleteMultipartUpload(req *CompleteMultipartUploadRequest) (resp *CompleteMultipartUploadOutput, err error) {
	resp = &CompleteMultipartUploadOutput{}

	var body io.Reader
	var contentType string

	contentType = "application/xml"
	b, err := xml.Marshal(req.MultipartUpload)
	if err != nil {
		return
	}
	body = bytes.NewReader(b)

	uri := c.client.Endpoint + "/{Bucket}/{Key+}"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	if req.Key != nil {
		uri = strings.Replace(uri, "{"+"Key"+"}", *req.Key, -1)
		uri = strings.Replace(uri, "{"+"Key+"+"}", *req.Key, -1)
	}

	q := url.Values{}

	if req.UploadID != nil {
		q.Set("uploadId", *req.UploadID)
	}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("POST", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("x-amz-expiration"); s != "" {

		if t, e := time.Parse(time.RFC1123, s); e != nil {
			err = e
			return
		} else {
			resp.Expiration = t
		}

	}

	if s := httpResp.Header.Get("x-amz-server-side-encryption-aws-kms-key-id"); s != "" {

		resp.SSEKMSKeyID = &s

	}

	if s := httpResp.Header.Get("x-amz-server-side-encryption"); s != "" {

		resp.ServerSideEncryption = &s

	}

	if s := httpResp.Header.Get("x-amz-version-id"); s != "" {

		resp.VersionID = &s

	}

	return
}

// CopyObject creates a copy of an object that is already stored in Amazon
// S3.
func (c *S3) CopyObject(req *CopyObjectRequest) (resp *CopyObjectOutput, err error) {
	resp = &CopyObjectOutput{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/{Bucket}/{Key+}"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	if req.Key != nil {
		uri = strings.Replace(uri, "{"+"Key"+"}", *req.Key, -1)
		uri = strings.Replace(uri, "{"+"Key+"+"}", *req.Key, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("PUT", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	if req.ACL != nil {
		httpReq.Header.Set("x-amz-acl", *req.ACL)
	}

	if req.CacheControl != nil {
		httpReq.Header.Set("Cache-Control", *req.CacheControl)
	}

	if req.ContentDisposition != nil {
		httpReq.Header.Set("Content-Disposition", *req.ContentDisposition)
	}

	if req.ContentEncoding != nil {
		httpReq.Header.Set("Content-Encoding", *req.ContentEncoding)
	}

	if req.ContentLanguage != nil {
		httpReq.Header.Set("Content-Language", *req.ContentLanguage)
	}

	if req.ContentType != nil {
		httpReq.Header.Set("Content-Type", *req.ContentType)
	}

	if req.CopySource != nil {
		httpReq.Header.Set("x-amz-copy-source", *req.CopySource)
	}

	if req.CopySourceIfMatch != nil {
		httpReq.Header.Set("x-amz-copy-source-if-match", *req.CopySourceIfMatch)
	}

	if req.CopySourceIfModifiedSince != (time.Time{}) {
		httpReq.Header.Set("x-amz-copy-source-if-modified-since", req.CopySourceIfModifiedSince.Format(time.RFC822))
	}

	if req.CopySourceIfNoneMatch != nil {
		httpReq.Header.Set("x-amz-copy-source-if-none-match", *req.CopySourceIfNoneMatch)
	}

	if req.CopySourceIfUnmodifiedSince != (time.Time{}) {
		httpReq.Header.Set("x-amz-copy-source-if-unmodified-since", req.CopySourceIfUnmodifiedSince.Format(time.RFC822))
	}

	if req.CopySourceSSECustomerAlgorithm != nil {
		httpReq.Header.Set("x-amz-copy-source-server-side-encryption-customer-algorithm", *req.CopySourceSSECustomerAlgorithm)
	}

	if req.CopySourceSSECustomerKey != nil {
		httpReq.Header.Set("x-amz-copy-source-server-side-encryption-customer-key", *req.CopySourceSSECustomerKey)
	}

	if req.CopySourceSSECustomerKeyMD5 != nil {
		httpReq.Header.Set("x-amz-copy-source-server-side-encryption-customer-key-MD5", *req.CopySourceSSECustomerKeyMD5)
	}

	if req.Expires != (time.Time{}) {
		httpReq.Header.Set("Expires", req.Expires.Format(time.RFC822))
	}

	if req.GrantFullControl != nil {
		httpReq.Header.Set("x-amz-grant-full-control", *req.GrantFullControl)
	}

	if req.GrantRead != nil {
		httpReq.Header.Set("x-amz-grant-read", *req.GrantRead)
	}

	if req.GrantReadACP != nil {
		httpReq.Header.Set("x-amz-grant-read-acp", *req.GrantReadACP)
	}

	if req.GrantWriteACP != nil {
		httpReq.Header.Set("x-amz-grant-write-acp", *req.GrantWriteACP)
	}

	if req.MetadataDirective != nil {
		httpReq.Header.Set("x-amz-metadata-directive", *req.MetadataDirective)
	}

	if req.SSECustomerAlgorithm != nil {
		httpReq.Header.Set("x-amz-server-side-encryption-customer-algorithm", *req.SSECustomerAlgorithm)
	}

	if req.SSECustomerKey != nil {
		httpReq.Header.Set("x-amz-server-side-encryption-customer-key", *req.SSECustomerKey)
	}

	if req.SSECustomerKeyMD5 != nil {
		httpReq.Header.Set("x-amz-server-side-encryption-customer-key-MD5", *req.SSECustomerKeyMD5)
	}

	if req.SSEKMSKeyID != nil {
		httpReq.Header.Set("x-amz-server-side-encryption-aws-kms-key-id", *req.SSEKMSKeyID)
	}

	if req.ServerSideEncryption != nil {
		httpReq.Header.Set("x-amz-server-side-encryption", *req.ServerSideEncryption)
	}

	if req.StorageClass != nil {
		httpReq.Header.Set("x-amz-storage-class", *req.StorageClass)
	}

	if req.WebsiteRedirectLocation != nil {
		httpReq.Header.Set("x-amz-website-redirect-location", *req.WebsiteRedirectLocation)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("x-amz-copy-source-version-id"); s != "" {

		resp.CopySourceVersionID = &s

	}

	if s := httpResp.Header.Get("x-amz-expiration"); s != "" {

		if t, e := time.Parse(time.RFC1123, s); e != nil {
			err = e
			return
		} else {
			resp.Expiration = t
		}

	}

	if s := httpResp.Header.Get("x-amz-server-side-encryption-customer-algorithm"); s != "" {

		resp.SSECustomerAlgorithm = &s

	}

	if s := httpResp.Header.Get("x-amz-server-side-encryption-customer-key-MD5"); s != "" {

		resp.SSECustomerKeyMD5 = &s

	}

	if s := httpResp.Header.Get("x-amz-server-side-encryption-aws-kms-key-id"); s != "" {

		resp.SSEKMSKeyID = &s

	}

	if s := httpResp.Header.Get("x-amz-server-side-encryption"); s != "" {

		resp.ServerSideEncryption = &s

	}

	return
}

// CreateBucket is undocumented.
func (c *S3) CreateBucket(req *CreateBucketRequest) (resp *CreateBucketOutput, err error) {
	resp = &CreateBucketOutput{}

	var body io.Reader
	var contentType string

	contentType = "application/xml"
	b, err := xml.Marshal(req.CreateBucketConfiguration)
	if err != nil {
		return
	}
	body = bytes.NewReader(b)

	uri := c.client.Endpoint + "/{Bucket}"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("PUT", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	if req.ACL != nil {
		httpReq.Header.Set("x-amz-acl", *req.ACL)
	}

	if req.GrantFullControl != nil {
		httpReq.Header.Set("x-amz-grant-full-control", *req.GrantFullControl)
	}

	if req.GrantRead != nil {
		httpReq.Header.Set("x-amz-grant-read", *req.GrantRead)
	}

	if req.GrantReadACP != nil {
		httpReq.Header.Set("x-amz-grant-read-acp", *req.GrantReadACP)
	}

	if req.GrantWrite != nil {
		httpReq.Header.Set("x-amz-grant-write", *req.GrantWrite)
	}

	if req.GrantWriteACP != nil {
		httpReq.Header.Set("x-amz-grant-write-acp", *req.GrantWriteACP)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("Location"); s != "" {

		resp.Location = &s

	}

	return
}

// CreateMultipartUpload initiates a multipart upload and returns an upload
// Note: After you initiate multipart upload and upload one or more parts,
// you must either complete or abort multipart upload in order to stop
// getting charged for storage of the uploaded parts. Only after you either
// complete or abort multipart upload, Amazon S3 frees up the parts storage
// and stops charging you for the parts storage.
func (c *S3) CreateMultipartUpload(req *CreateMultipartUploadRequest) (resp *CreateMultipartUploadOutput, err error) {
	resp = &CreateMultipartUploadOutput{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/{Bucket}/{Key+}?uploads"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	if req.Key != nil {
		uri = strings.Replace(uri, "{"+"Key"+"}", *req.Key, -1)
		uri = strings.Replace(uri, "{"+"Key+"+"}", *req.Key, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("POST", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	if req.ACL != nil {
		httpReq.Header.Set("x-amz-acl", *req.ACL)
	}

	if req.CacheControl != nil {
		httpReq.Header.Set("Cache-Control", *req.CacheControl)
	}

	if req.ContentDisposition != nil {
		httpReq.Header.Set("Content-Disposition", *req.ContentDisposition)
	}

	if req.ContentEncoding != nil {
		httpReq.Header.Set("Content-Encoding", *req.ContentEncoding)
	}

	if req.ContentLanguage != nil {
		httpReq.Header.Set("Content-Language", *req.ContentLanguage)
	}

	if req.ContentType != nil {
		httpReq.Header.Set("Content-Type", *req.ContentType)
	}

	if req.Expires != (time.Time{}) {
		httpReq.Header.Set("Expires", req.Expires.Format(time.RFC822))
	}

	if req.GrantFullControl != nil {
		httpReq.Header.Set("x-amz-grant-full-control", *req.GrantFullControl)
	}

	if req.GrantRead != nil {
		httpReq.Header.Set("x-amz-grant-read", *req.GrantRead)
	}

	if req.GrantReadACP != nil {
		httpReq.Header.Set("x-amz-grant-read-acp", *req.GrantReadACP)
	}

	if req.GrantWriteACP != nil {
		httpReq.Header.Set("x-amz-grant-write-acp", *req.GrantWriteACP)
	}

	if req.SSECustomerAlgorithm != nil {
		httpReq.Header.Set("x-amz-server-side-encryption-customer-algorithm", *req.SSECustomerAlgorithm)
	}

	if req.SSECustomerKey != nil {
		httpReq.Header.Set("x-amz-server-side-encryption-customer-key", *req.SSECustomerKey)
	}

	if req.SSECustomerKeyMD5 != nil {
		httpReq.Header.Set("x-amz-server-side-encryption-customer-key-MD5", *req.SSECustomerKeyMD5)
	}

	if req.SSEKMSKeyID != nil {
		httpReq.Header.Set("x-amz-server-side-encryption-aws-kms-key-id", *req.SSEKMSKeyID)
	}

	if req.ServerSideEncryption != nil {
		httpReq.Header.Set("x-amz-server-side-encryption", *req.ServerSideEncryption)
	}

	if req.StorageClass != nil {
		httpReq.Header.Set("x-amz-storage-class", *req.StorageClass)
	}

	if req.WebsiteRedirectLocation != nil {
		httpReq.Header.Set("x-amz-website-redirect-location", *req.WebsiteRedirectLocation)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("x-amz-server-side-encryption-customer-algorithm"); s != "" {

		resp.SSECustomerAlgorithm = &s

	}

	if s := httpResp.Header.Get("x-amz-server-side-encryption-customer-key-MD5"); s != "" {

		resp.SSECustomerKeyMD5 = &s

	}

	if s := httpResp.Header.Get("x-amz-server-side-encryption-aws-kms-key-id"); s != "" {

		resp.SSEKMSKeyID = &s

	}

	if s := httpResp.Header.Get("x-amz-server-side-encryption"); s != "" {

		resp.ServerSideEncryption = &s

	}

	return
}

// DeleteBucket deletes the bucket. All objects (including all object
// versions and Delete Markers) in the bucket must be deleted before the
// bucket itself can be deleted.
func (c *S3) DeleteBucket(req *DeleteBucketRequest) (err error) {
	// NRE

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/{Bucket}"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("DELETE", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()

	return
}

// DeleteBucketCors deletes the cors configuration information set for the
// bucket.
func (c *S3) DeleteBucketCors(req *DeleteBucketCorsRequest) (err error) {
	// NRE

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/{Bucket}?cors"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("DELETE", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()

	return
}

// DeleteBucketLifecycle deletes the lifecycle configuration from the
// bucket.
func (c *S3) DeleteBucketLifecycle(req *DeleteBucketLifecycleRequest) (err error) {
	// NRE

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/{Bucket}?lifecycle"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("DELETE", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()

	return
}

// DeleteBucketPolicy is undocumented.
func (c *S3) DeleteBucketPolicy(req *DeleteBucketPolicyRequest) (err error) {
	// NRE

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/{Bucket}?policy"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("DELETE", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()

	return
}

// DeleteBucketTagging is undocumented.
func (c *S3) DeleteBucketTagging(req *DeleteBucketTaggingRequest) (err error) {
	// NRE

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/{Bucket}?tagging"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("DELETE", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()

	return
}

// DeleteBucketWebsite this operation removes the website configuration
// from the bucket.
func (c *S3) DeleteBucketWebsite(req *DeleteBucketWebsiteRequest) (err error) {
	// NRE

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/{Bucket}?website"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("DELETE", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()

	return
}

// DeleteObject removes the null version (if there is one) of an object and
// inserts a delete marker, which becomes the latest version of the object.
// If there isn't a null version, Amazon S3 does not remove any objects.
func (c *S3) DeleteObject(req *DeleteObjectRequest) (resp *DeleteObjectOutput, err error) {
	resp = &DeleteObjectOutput{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/{Bucket}/{Key+}"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	if req.Key != nil {
		uri = strings.Replace(uri, "{"+"Key"+"}", *req.Key, -1)
		uri = strings.Replace(uri, "{"+"Key+"+"}", *req.Key, -1)
	}

	q := url.Values{}

	if req.VersionID != nil {
		q.Set("versionId", *req.VersionID)
	}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("DELETE", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	if req.MFA != nil {
		httpReq.Header.Set("x-amz-mfa", *req.MFA)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("x-amz-delete-marker"); s != "" {

		if v, e := strconv.ParseBool(s); e != nil {
			err = e
			return
		} else {
			resp.DeleteMarker = &v
		}

	}

	if s := httpResp.Header.Get("x-amz-version-id"); s != "" {

		resp.VersionID = &s

	}

	return
}

// DeleteObjects this operation enables you to delete multiple objects from
// a bucket using a single request. You may specify up to 1000 keys.
func (c *S3) DeleteObjects(req *DeleteObjectsRequest) (resp *DeleteObjectsOutput, err error) {
	resp = &DeleteObjectsOutput{}

	var body io.Reader
	var contentType string

	contentType = "application/xml"
	b, err := xml.Marshal(req.Delete)
	if err != nil {
		return
	}
	body = bytes.NewReader(b)

	uri := c.client.Endpoint + "/{Bucket}?delete"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("POST", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	if req.MFA != nil {
		httpReq.Header.Set("x-amz-mfa", *req.MFA)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	return
}

// GetBucketAcl is undocumented.
func (c *S3) GetBucketAcl(req *GetBucketAclRequest) (resp *GetBucketAclOutput, err error) {
	resp = &GetBucketAclOutput{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/{Bucket}?acl"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	return
}

// GetBucketCors is undocumented.
func (c *S3) GetBucketCors(req *GetBucketCorsRequest) (resp *GetBucketCorsOutput, err error) {
	resp = &GetBucketCorsOutput{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/{Bucket}?cors"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	return
}

// GetBucketLifecycle returns the lifecycle configuration information set
// on the bucket.
func (c *S3) GetBucketLifecycle(req *GetBucketLifecycleRequest) (resp *GetBucketLifecycleOutput, err error) {
	resp = &GetBucketLifecycleOutput{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/{Bucket}?lifecycle"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	return
}

// GetBucketLocation is undocumented.
func (c *S3) GetBucketLocation(req *GetBucketLocationRequest) (resp *GetBucketLocationOutput, err error) {
	resp = &GetBucketLocationOutput{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/{Bucket}?location"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	return
}

// GetBucketLogging returns the logging status of a bucket and the
// permissions users have to view and modify that status. To use you must
// be the bucket owner.
func (c *S3) GetBucketLogging(req *GetBucketLoggingRequest) (resp *GetBucketLoggingOutput, err error) {
	resp = &GetBucketLoggingOutput{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/{Bucket}?logging"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	return
}

// GetBucketNotification is undocumented.
func (c *S3) GetBucketNotification(req *GetBucketNotificationRequest) (resp *GetBucketNotificationOutput, err error) {
	resp = &GetBucketNotificationOutput{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/{Bucket}?notification"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	return
}

// GetBucketPolicy is undocumented.
func (c *S3) GetBucketPolicy(req *GetBucketPolicyRequest) (resp *GetBucketPolicyOutput, err error) {
	resp = &GetBucketPolicyOutput{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/{Bucket}?policy"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	return
}

// GetBucketRequestPayment returns the request payment configuration of a
// bucket.
func (c *S3) GetBucketRequestPayment(req *GetBucketRequestPaymentRequest) (resp *GetBucketRequestPaymentOutput, err error) {
	resp = &GetBucketRequestPaymentOutput{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/{Bucket}?requestPayment"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	return
}

// GetBucketTagging is undocumented.
func (c *S3) GetBucketTagging(req *GetBucketTaggingRequest) (resp *GetBucketTaggingOutput, err error) {
	resp = &GetBucketTaggingOutput{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/{Bucket}?tagging"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	return
}

// GetBucketVersioning is undocumented.
func (c *S3) GetBucketVersioning(req *GetBucketVersioningRequest) (resp *GetBucketVersioningOutput, err error) {
	resp = &GetBucketVersioningOutput{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/{Bucket}?versioning"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	return
}

// GetBucketWebsite is undocumented.
func (c *S3) GetBucketWebsite(req *GetBucketWebsiteRequest) (resp *GetBucketWebsiteOutput, err error) {
	resp = &GetBucketWebsiteOutput{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/{Bucket}?website"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	return
}

// GetObject is undocumented.
func (c *S3) GetObject(req *GetObjectRequest) (resp *GetObjectOutput, err error) {
	resp = &GetObjectOutput{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/{Bucket}/{Key+}"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	if req.Key != nil {
		uri = strings.Replace(uri, "{"+"Key"+"}", *req.Key, -1)
		uri = strings.Replace(uri, "{"+"Key+"+"}", *req.Key, -1)
	}

	q := url.Values{}

	if req.ResponseCacheControl != nil {
		q.Set("response-cache-control", *req.ResponseCacheControl)
	}

	if req.ResponseContentDisposition != nil {
		q.Set("response-content-disposition", *req.ResponseContentDisposition)
	}

	if req.ResponseContentEncoding != nil {
		q.Set("response-content-encoding", *req.ResponseContentEncoding)
	}

	if req.ResponseContentLanguage != nil {
		q.Set("response-content-language", *req.ResponseContentLanguage)
	}

	if req.ResponseContentType != nil {
		q.Set("response-content-type", *req.ResponseContentType)
	}

	if req.ResponseExpires != (time.Time{}) {
		q.Set("response-expires", req.ResponseExpires.Format(time.RFC822))
	}

	if req.VersionID != nil {
		q.Set("versionId", *req.VersionID)
	}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	if req.IfMatch != nil {
		httpReq.Header.Set("If-Match", *req.IfMatch)
	}

	if req.IfModifiedSince != (time.Time{}) {
		httpReq.Header.Set("If-Modified-Since", req.IfModifiedSince.Format(time.RFC822))
	}

	if req.IfNoneMatch != nil {
		httpReq.Header.Set("If-None-Match", *req.IfNoneMatch)
	}

	if req.IfUnmodifiedSince != (time.Time{}) {
		httpReq.Header.Set("If-Unmodified-Since", req.IfUnmodifiedSince.Format(time.RFC822))
	}

	if req.Range != nil {
		httpReq.Header.Set("Range", *req.Range)
	}

	if req.SSECustomerAlgorithm != nil {
		httpReq.Header.Set("x-amz-server-side-encryption-customer-algorithm", *req.SSECustomerAlgorithm)
	}

	if req.SSECustomerKey != nil {
		httpReq.Header.Set("x-amz-server-side-encryption-customer-key", *req.SSECustomerKey)
	}

	if req.SSECustomerKeyMD5 != nil {
		httpReq.Header.Set("x-amz-server-side-encryption-customer-key-MD5", *req.SSECustomerKeyMD5)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	resp.Body = httpResp.Body

	if s := httpResp.Header.Get("accept-ranges"); s != "" {

		resp.AcceptRanges = &s

	}

	if s := httpResp.Header.Get("Cache-Control"); s != "" {

		resp.CacheControl = &s

	}

	if s := httpResp.Header.Get("Content-Disposition"); s != "" {

		resp.ContentDisposition = &s

	}

	if s := httpResp.Header.Get("Content-Encoding"); s != "" {

		resp.ContentEncoding = &s

	}

	if s := httpResp.Header.Get("Content-Language"); s != "" {

		resp.ContentLanguage = &s

	}

	if s := httpResp.Header.Get("Content-Length"); s != "" {

		if n, e := strconv.Atoi(s); e != nil {
			err = e
			return
		} else {
			resp.ContentLength = &n
		}

	}

	if s := httpResp.Header.Get("Content-Type"); s != "" {

		resp.ContentType = &s

	}

	if s := httpResp.Header.Get("x-amz-delete-marker"); s != "" {

		if v, e := strconv.ParseBool(s); e != nil {
			err = e
			return
		} else {
			resp.DeleteMarker = &v
		}

	}

	if s := httpResp.Header.Get("ETag"); s != "" {

		resp.ETag = &s

	}

	if s := httpResp.Header.Get("x-amz-expiration"); s != "" {

		if t, e := time.Parse(time.RFC1123, s); e != nil {
			err = e
			return
		} else {
			resp.Expiration = t
		}

	}

	if s := httpResp.Header.Get("Expires"); s != "" {

		if t, e := time.Parse(time.RFC1123, s); e != nil {
			err = e
			return
		} else {
			resp.Expires = t
		}

	}

	if s := httpResp.Header.Get("Last-Modified"); s != "" {

		if t, e := time.Parse(time.RFC1123, s); e != nil {
			err = e
			return
		} else {
			resp.LastModified = t
		}

	}

	resp.Metadata = map[string]string{}
	for name := range httpResp.Header {
		if strings.HasPrefix(name, "headers") {
			resp.Metadata[name] = httpResp.Header.Get(name)
		}
	}

	if s := httpResp.Header.Get("x-amz-missing-meta"); s != "" {

		if n, e := strconv.Atoi(s); e != nil {
			err = e
			return
		} else {
			resp.MissingMeta = &n
		}

	}

	if s := httpResp.Header.Get("x-amz-restore"); s != "" {

		resp.Restore = &s

	}

	if s := httpResp.Header.Get("x-amz-server-side-encryption-customer-algorithm"); s != "" {

		resp.SSECustomerAlgorithm = &s

	}

	if s := httpResp.Header.Get("x-amz-server-side-encryption-customer-key-MD5"); s != "" {

		resp.SSECustomerKeyMD5 = &s

	}

	if s := httpResp.Header.Get("x-amz-server-side-encryption-aws-kms-key-id"); s != "" {

		resp.SSEKMSKeyID = &s

	}

	if s := httpResp.Header.Get("x-amz-server-side-encryption"); s != "" {

		resp.ServerSideEncryption = &s

	}

	if s := httpResp.Header.Get("x-amz-version-id"); s != "" {

		resp.VersionID = &s

	}

	if s := httpResp.Header.Get("x-amz-website-redirect-location"); s != "" {

		resp.WebsiteRedirectLocation = &s

	}

	return
}

// GetObjectAcl is undocumented.
func (c *S3) GetObjectAcl(req *GetObjectAclRequest) (resp *GetObjectAclOutput, err error) {
	resp = &GetObjectAclOutput{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/{Bucket}/{Key+}?acl"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	if req.Key != nil {
		uri = strings.Replace(uri, "{"+"Key"+"}", *req.Key, -1)
		uri = strings.Replace(uri, "{"+"Key+"+"}", *req.Key, -1)
	}

	q := url.Values{}

	if req.VersionID != nil {
		q.Set("versionId", *req.VersionID)
	}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	return
}

// GetObjectTorrent is undocumented.
func (c *S3) GetObjectTorrent(req *GetObjectTorrentRequest) (resp *GetObjectTorrentOutput, err error) {
	resp = &GetObjectTorrentOutput{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/{Bucket}/{Key+}?torrent"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	if req.Key != nil {
		uri = strings.Replace(uri, "{"+"Key"+"}", *req.Key, -1)
		uri = strings.Replace(uri, "{"+"Key+"+"}", *req.Key, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	resp.Body = httpResp.Body

	return
}

// HeadBucket this operation is useful to determine if a bucket exists and
// you have permission to access it.
func (c *S3) HeadBucket(req *HeadBucketRequest) (err error) {
	// NRE

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/{Bucket}"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("HEAD", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()

	return
}

// HeadObject the operation retrieves metadata from an object without
// returning the object itself. This operation is useful if you're only
// interested in an object's metadata. To use you must have access to the
// object.
func (c *S3) HeadObject(req *HeadObjectRequest) (resp *HeadObjectOutput, err error) {
	resp = &HeadObjectOutput{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/{Bucket}/{Key+}"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	if req.Key != nil {
		uri = strings.Replace(uri, "{"+"Key"+"}", *req.Key, -1)
		uri = strings.Replace(uri, "{"+"Key+"+"}", *req.Key, -1)
	}

	q := url.Values{}

	if req.VersionID != nil {
		q.Set("versionId", *req.VersionID)
	}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("HEAD", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	if req.IfMatch != nil {
		httpReq.Header.Set("If-Match", *req.IfMatch)
	}

	if req.IfModifiedSince != (time.Time{}) {
		httpReq.Header.Set("If-Modified-Since", req.IfModifiedSince.Format(time.RFC822))
	}

	if req.IfNoneMatch != nil {
		httpReq.Header.Set("If-None-Match", *req.IfNoneMatch)
	}

	if req.IfUnmodifiedSince != (time.Time{}) {
		httpReq.Header.Set("If-Unmodified-Since", req.IfUnmodifiedSince.Format(time.RFC822))
	}

	if req.Range != nil {
		httpReq.Header.Set("Range", *req.Range)
	}

	if req.SSECustomerAlgorithm != nil {
		httpReq.Header.Set("x-amz-server-side-encryption-customer-algorithm", *req.SSECustomerAlgorithm)
	}

	if req.SSECustomerKey != nil {
		httpReq.Header.Set("x-amz-server-side-encryption-customer-key", *req.SSECustomerKey)
	}

	if req.SSECustomerKeyMD5 != nil {
		httpReq.Header.Set("x-amz-server-side-encryption-customer-key-MD5", *req.SSECustomerKeyMD5)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("accept-ranges"); s != "" {

		resp.AcceptRanges = &s

	}

	if s := httpResp.Header.Get("Cache-Control"); s != "" {

		resp.CacheControl = &s

	}

	if s := httpResp.Header.Get("Content-Disposition"); s != "" {

		resp.ContentDisposition = &s

	}

	if s := httpResp.Header.Get("Content-Encoding"); s != "" {

		resp.ContentEncoding = &s

	}

	if s := httpResp.Header.Get("Content-Language"); s != "" {

		resp.ContentLanguage = &s

	}

	if s := httpResp.Header.Get("Content-Length"); s != "" {

		if n, e := strconv.Atoi(s); e != nil {
			err = e
			return
		} else {
			resp.ContentLength = &n
		}

	}

	if s := httpResp.Header.Get("Content-Type"); s != "" {

		resp.ContentType = &s

	}

	if s := httpResp.Header.Get("x-amz-delete-marker"); s != "" {

		if v, e := strconv.ParseBool(s); e != nil {
			err = e
			return
		} else {
			resp.DeleteMarker = &v
		}

	}

	if s := httpResp.Header.Get("ETag"); s != "" {

		resp.ETag = &s

	}

	if s := httpResp.Header.Get("x-amz-expiration"); s != "" {

		if t, e := time.Parse(time.RFC1123, s); e != nil {
			err = e
			return
		} else {
			resp.Expiration = t
		}

	}

	if s := httpResp.Header.Get("Expires"); s != "" {

		if t, e := time.Parse(time.RFC1123, s); e != nil {
			err = e
			return
		} else {
			resp.Expires = t
		}

	}

	if s := httpResp.Header.Get("Last-Modified"); s != "" {

		if t, e := time.Parse(time.RFC1123, s); e != nil {
			err = e
			return
		} else {
			resp.LastModified = t
		}

	}

	resp.Metadata = map[string]string{}
	for name := range httpResp.Header {
		if strings.HasPrefix(name, "headers") {
			resp.Metadata[name] = httpResp.Header.Get(name)
		}
	}

	if s := httpResp.Header.Get("x-amz-missing-meta"); s != "" {

		if n, e := strconv.Atoi(s); e != nil {
			err = e
			return
		} else {
			resp.MissingMeta = &n
		}

	}

	if s := httpResp.Header.Get("x-amz-restore"); s != "" {

		resp.Restore = &s

	}

	if s := httpResp.Header.Get("x-amz-server-side-encryption-customer-algorithm"); s != "" {

		resp.SSECustomerAlgorithm = &s

	}

	if s := httpResp.Header.Get("x-amz-server-side-encryption-customer-key-MD5"); s != "" {

		resp.SSECustomerKeyMD5 = &s

	}

	if s := httpResp.Header.Get("x-amz-server-side-encryption-aws-kms-key-id"); s != "" {

		resp.SSEKMSKeyID = &s

	}

	if s := httpResp.Header.Get("x-amz-server-side-encryption"); s != "" {

		resp.ServerSideEncryption = &s

	}

	if s := httpResp.Header.Get("x-amz-version-id"); s != "" {

		resp.VersionID = &s

	}

	if s := httpResp.Header.Get("x-amz-website-redirect-location"); s != "" {

		resp.WebsiteRedirectLocation = &s

	}

	return
}

// ListBuckets returns a list of all buckets owned by the authenticated
// sender of the request.
func (c *S3) ListBuckets() (resp *ListBucketsOutput, err error) {
	resp = &ListBucketsOutput{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/"

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	return
}

// ListMultipartUploads this operation lists in-progress multipart uploads.
func (c *S3) ListMultipartUploads(req *ListMultipartUploadsRequest) (resp *ListMultipartUploadsOutput, err error) {
	resp = &ListMultipartUploadsOutput{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/{Bucket}?uploads"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	q := url.Values{}

	if req.Delimiter != nil {
		q.Set("delimiter", *req.Delimiter)
	}

	if req.EncodingType != nil {
		q.Set("encoding-type", *req.EncodingType)
	}

	if req.KeyMarker != nil {
		q.Set("key-marker", *req.KeyMarker)
	}

	if req.MaxUploads != nil {
		q.Set("max-uploads", strconv.Itoa(*req.MaxUploads))
	}

	if req.Prefix != nil {
		q.Set("prefix", *req.Prefix)
	}

	if req.UploadIDMarker != nil {
		q.Set("upload-id-marker", *req.UploadIDMarker)
	}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	return
}

// ListObjectVersions returns metadata about all of the versions of objects
// in a bucket.
func (c *S3) ListObjectVersions(req *ListObjectVersionsRequest) (resp *ListObjectVersionsOutput, err error) {
	resp = &ListObjectVersionsOutput{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/{Bucket}?versions"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	q := url.Values{}

	if req.Delimiter != nil {
		q.Set("delimiter", *req.Delimiter)
	}

	if req.EncodingType != nil {
		q.Set("encoding-type", *req.EncodingType)
	}

	if req.KeyMarker != nil {
		q.Set("key-marker", *req.KeyMarker)
	}

	if req.MaxKeys != nil {
		q.Set("max-keys", strconv.Itoa(*req.MaxKeys))
	}

	if req.Prefix != nil {
		q.Set("prefix", *req.Prefix)
	}

	if req.VersionIDMarker != nil {
		q.Set("version-id-marker", *req.VersionIDMarker)
	}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	return
}

// ListObjects returns some or all (up to 1000) of the objects in a bucket.
// You can use the request parameters as selection criteria to return a
// subset of the objects in a bucket.
func (c *S3) ListObjects(req *ListObjectsRequest) (resp *ListObjectsOutput, err error) {
	resp = &ListObjectsOutput{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/{Bucket}"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	q := url.Values{}

	if req.Delimiter != nil {
		q.Set("delimiter", *req.Delimiter)
	}

	if req.EncodingType != nil {
		q.Set("encoding-type", *req.EncodingType)
	}

	if req.Marker != nil {
		q.Set("marker", *req.Marker)
	}

	if req.MaxKeys != nil {
		q.Set("max-keys", strconv.Itoa(*req.MaxKeys))
	}

	if req.Prefix != nil {
		q.Set("prefix", *req.Prefix)
	}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	return
}

// ListParts lists the parts that have been uploaded for a specific
// multipart upload.
func (c *S3) ListParts(req *ListPartsRequest) (resp *ListPartsOutput, err error) {
	resp = &ListPartsOutput{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/{Bucket}/{Key+}"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	if req.Key != nil {
		uri = strings.Replace(uri, "{"+"Key"+"}", *req.Key, -1)
		uri = strings.Replace(uri, "{"+"Key+"+"}", *req.Key, -1)
	}

	q := url.Values{}

	if req.MaxParts != nil {
		q.Set("max-parts", strconv.Itoa(*req.MaxParts))
	}

	if req.PartNumberMarker != nil {
		q.Set("part-number-marker", strconv.Itoa(*req.PartNumberMarker))
	}

	if req.UploadID != nil {
		q.Set("uploadId", *req.UploadID)
	}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	return
}

// PutBucketAcl sets the permissions on a bucket using access control lists
func (c *S3) PutBucketAcl(req *PutBucketAclRequest) (err error) {
	// NRE

	var body io.Reader
	var contentType string

	contentType = "application/xml"
	b, err := xml.Marshal(req.AccessControlPolicy)
	if err != nil {
		return
	}
	body = bytes.NewReader(b)

	uri := c.client.Endpoint + "/{Bucket}?acl"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("PUT", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	if req.ACL != nil {
		httpReq.Header.Set("x-amz-acl", *req.ACL)
	}

	if req.ContentMD5 != nil {
		httpReq.Header.Set("Content-MD5", *req.ContentMD5)
	}

	if req.GrantFullControl != nil {
		httpReq.Header.Set("x-amz-grant-full-control", *req.GrantFullControl)
	}

	if req.GrantRead != nil {
		httpReq.Header.Set("x-amz-grant-read", *req.GrantRead)
	}

	if req.GrantReadACP != nil {
		httpReq.Header.Set("x-amz-grant-read-acp", *req.GrantReadACP)
	}

	if req.GrantWrite != nil {
		httpReq.Header.Set("x-amz-grant-write", *req.GrantWrite)
	}

	if req.GrantWriteACP != nil {
		httpReq.Header.Set("x-amz-grant-write-acp", *req.GrantWriteACP)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()

	return
}

// PutBucketCors is undocumented.
func (c *S3) PutBucketCors(req *PutBucketCorsRequest) (err error) {
	// NRE

	var body io.Reader
	var contentType string

	contentType = "application/xml"
	b, err := xml.Marshal(req.CORSConfiguration)
	if err != nil {
		return
	}
	body = bytes.NewReader(b)

	uri := c.client.Endpoint + "/{Bucket}?cors"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("PUT", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	if req.ContentMD5 != nil {
		httpReq.Header.Set("Content-MD5", *req.ContentMD5)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()

	return
}

// PutBucketLifecycle sets lifecycle configuration for your bucket. If a
// lifecycle configuration exists, it replaces it.
func (c *S3) PutBucketLifecycle(req *PutBucketLifecycleRequest) (err error) {
	// NRE

	var body io.Reader
	var contentType string

	contentType = "application/xml"
	b, err := xml.Marshal(req.LifecycleConfiguration)
	if err != nil {
		return
	}
	body = bytes.NewReader(b)

	uri := c.client.Endpoint + "/{Bucket}?lifecycle"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("PUT", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	if req.ContentMD5 != nil {
		httpReq.Header.Set("Content-MD5", *req.ContentMD5)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()

	return
}

// PutBucketLogging set the logging parameters for a bucket and to specify
// permissions for who can view and modify the logging parameters. To set
// the logging status of a bucket, you must be the bucket owner.
func (c *S3) PutBucketLogging(req *PutBucketLoggingRequest) (err error) {
	// NRE

	var body io.Reader
	var contentType string

	contentType = "application/xml"
	b, err := xml.Marshal(req.BucketLoggingStatus)
	if err != nil {
		return
	}
	body = bytes.NewReader(b)

	uri := c.client.Endpoint + "/{Bucket}?logging"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("PUT", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	if req.ContentMD5 != nil {
		httpReq.Header.Set("Content-MD5", *req.ContentMD5)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()

	return
}

// PutBucketNotification enables notifications of specified events for a
// bucket.
func (c *S3) PutBucketNotification(req *PutBucketNotificationRequest) (err error) {
	// NRE

	var body io.Reader
	var contentType string

	contentType = "application/xml"
	b, err := xml.Marshal(req.NotificationConfiguration)
	if err != nil {
		return
	}
	body = bytes.NewReader(b)

	uri := c.client.Endpoint + "/{Bucket}?notification"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("PUT", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	if req.ContentMD5 != nil {
		httpReq.Header.Set("Content-MD5", *req.ContentMD5)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()

	return
}

// PutBucketPolicy replaces a policy on a bucket. If the bucket already has
// a policy, the one in this request completely replaces it.
func (c *S3) PutBucketPolicy(req *PutBucketPolicyRequest) (err error) {
	// NRE

	var body io.Reader
	var contentType string

	contentType = "application/xml"
	b, err := xml.Marshal(req.Policy)
	if err != nil {
		return
	}
	body = bytes.NewReader(b)

	uri := c.client.Endpoint + "/{Bucket}?policy"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("PUT", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	if req.ContentMD5 != nil {
		httpReq.Header.Set("Content-MD5", *req.ContentMD5)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()

	return
}

// PutBucketRequestPayment sets the request payment configuration for a
// bucket. By default, the bucket owner pays for downloads from the bucket.
// This configuration parameter enables the bucket owner (only) to specify
// that the person requesting the download will be charged for the
// download.
func (c *S3) PutBucketRequestPayment(req *PutBucketRequestPaymentRequest) (err error) {
	// NRE

	var body io.Reader
	var contentType string

	contentType = "application/xml"
	b, err := xml.Marshal(req.RequestPaymentConfiguration)
	if err != nil {
		return
	}
	body = bytes.NewReader(b)

	uri := c.client.Endpoint + "/{Bucket}?requestPayment"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("PUT", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	if req.ContentMD5 != nil {
		httpReq.Header.Set("Content-MD5", *req.ContentMD5)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()

	return
}

// PutBucketTagging is undocumented.
func (c *S3) PutBucketTagging(req *PutBucketTaggingRequest) (err error) {
	// NRE

	var body io.Reader
	var contentType string

	contentType = "application/xml"
	b, err := xml.Marshal(req.Tagging)
	if err != nil {
		return
	}
	body = bytes.NewReader(b)

	uri := c.client.Endpoint + "/{Bucket}?tagging"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("PUT", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	if req.ContentMD5 != nil {
		httpReq.Header.Set("Content-MD5", *req.ContentMD5)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()

	return
}

// PutBucketVersioning sets the versioning state of an existing bucket. To
// set the versioning state, you must be the bucket owner.
func (c *S3) PutBucketVersioning(req *PutBucketVersioningRequest) (err error) {
	// NRE

	var body io.Reader
	var contentType string

	contentType = "application/xml"
	b, err := xml.Marshal(req.VersioningConfiguration)
	if err != nil {
		return
	}
	body = bytes.NewReader(b)

	uri := c.client.Endpoint + "/{Bucket}?versioning"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("PUT", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	if req.ContentMD5 != nil {
		httpReq.Header.Set("Content-MD5", *req.ContentMD5)
	}

	if req.MFA != nil {
		httpReq.Header.Set("x-amz-mfa", *req.MFA)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()

	return
}

// PutBucketWebsite is undocumented.
func (c *S3) PutBucketWebsite(req *PutBucketWebsiteRequest) (err error) {
	// NRE

	var body io.Reader
	var contentType string

	contentType = "application/xml"
	b, err := xml.Marshal(req.WebsiteConfiguration)
	if err != nil {
		return
	}
	body = bytes.NewReader(b)

	uri := c.client.Endpoint + "/{Bucket}?website"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("PUT", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	if req.ContentMD5 != nil {
		httpReq.Header.Set("Content-MD5", *req.ContentMD5)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()

	return
}

// PutObject is undocumented.
func (c *S3) PutObject(req *PutObjectRequest) (resp *PutObjectOutput, err error) {
	resp = &PutObjectOutput{}

	var body io.Reader
	var contentType string

	body = req.Body

	uri := c.client.Endpoint + "/{Bucket}/{Key+}"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	if req.Key != nil {
		uri = strings.Replace(uri, "{"+"Key"+"}", *req.Key, -1)
		uri = strings.Replace(uri, "{"+"Key+"+"}", *req.Key, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("PUT", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	if req.ACL != nil {
		httpReq.Header.Set("x-amz-acl", *req.ACL)
	}

	if req.CacheControl != nil {
		httpReq.Header.Set("Cache-Control", *req.CacheControl)
	}

	if req.ContentDisposition != nil {
		httpReq.Header.Set("Content-Disposition", *req.ContentDisposition)
	}

	if req.ContentEncoding != nil {
		httpReq.Header.Set("Content-Encoding", *req.ContentEncoding)
	}

	if req.ContentLanguage != nil {
		httpReq.Header.Set("Content-Language", *req.ContentLanguage)
	}

	if req.ContentLength != nil {
		httpReq.ContentLength = int64(*req.ContentLength)
	}

	if req.ContentMD5 != nil {
		httpReq.Header.Set("Content-MD5", *req.ContentMD5)
	}

	if req.ContentType != nil {
		httpReq.Header.Set("Content-Type", *req.ContentType)
	}

	if req.Expires != (time.Time{}) {
		httpReq.Header.Set("Expires", req.Expires.Format(time.RFC822))
	}

	if req.GrantFullControl != nil {
		httpReq.Header.Set("x-amz-grant-full-control", *req.GrantFullControl)
	}

	if req.GrantRead != nil {
		httpReq.Header.Set("x-amz-grant-read", *req.GrantRead)
	}

	if req.GrantReadACP != nil {
		httpReq.Header.Set("x-amz-grant-read-acp", *req.GrantReadACP)
	}

	if req.GrantWriteACP != nil {
		httpReq.Header.Set("x-amz-grant-write-acp", *req.GrantWriteACP)
	}

	if req.SSECustomerAlgorithm != nil {
		httpReq.Header.Set("x-amz-server-side-encryption-customer-algorithm", *req.SSECustomerAlgorithm)
	}

	if req.SSECustomerKey != nil {
		httpReq.Header.Set("x-amz-server-side-encryption-customer-key", *req.SSECustomerKey)
	}

	if req.SSECustomerKeyMD5 != nil {
		httpReq.Header.Set("x-amz-server-side-encryption-customer-key-MD5", *req.SSECustomerKeyMD5)
	}

	if req.SSEKMSKeyID != nil {
		httpReq.Header.Set("x-amz-server-side-encryption-aws-kms-key-id", *req.SSEKMSKeyID)
	}

	if req.ServerSideEncryption != nil {
		httpReq.Header.Set("x-amz-server-side-encryption", *req.ServerSideEncryption)
	}

	if req.StorageClass != nil {
		httpReq.Header.Set("x-amz-storage-class", *req.StorageClass)
	}

	if req.WebsiteRedirectLocation != nil {
		httpReq.Header.Set("x-amz-website-redirect-location", *req.WebsiteRedirectLocation)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("ETag"); s != "" {

		resp.ETag = &s

	}

	if s := httpResp.Header.Get("x-amz-expiration"); s != "" {

		if t, e := time.Parse(time.RFC1123, s); e != nil {
			err = e
			return
		} else {
			resp.Expiration = t
		}

	}

	if s := httpResp.Header.Get("x-amz-server-side-encryption-customer-algorithm"); s != "" {

		resp.SSECustomerAlgorithm = &s

	}

	if s := httpResp.Header.Get("x-amz-server-side-encryption-customer-key-MD5"); s != "" {

		resp.SSECustomerKeyMD5 = &s

	}

	if s := httpResp.Header.Get("x-amz-server-side-encryption-aws-kms-key-id"); s != "" {

		resp.SSEKMSKeyID = &s

	}

	if s := httpResp.Header.Get("x-amz-server-side-encryption"); s != "" {

		resp.ServerSideEncryption = &s

	}

	if s := httpResp.Header.Get("x-amz-version-id"); s != "" {

		resp.VersionID = &s

	}

	return
}

// PutObjectAcl uses the acl subresource to set the access control list
// permissions for an object that already exists in a bucket
func (c *S3) PutObjectAcl(req *PutObjectAclRequest) (err error) {
	// NRE

	var body io.Reader
	var contentType string

	contentType = "application/xml"
	b, err := xml.Marshal(req.AccessControlPolicy)
	if err != nil {
		return
	}
	body = bytes.NewReader(b)

	uri := c.client.Endpoint + "/{Bucket}/{Key+}?acl"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	if req.Key != nil {
		uri = strings.Replace(uri, "{"+"Key"+"}", *req.Key, -1)
		uri = strings.Replace(uri, "{"+"Key+"+"}", *req.Key, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("PUT", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	if req.ACL != nil {
		httpReq.Header.Set("x-amz-acl", *req.ACL)
	}

	if req.ContentMD5 != nil {
		httpReq.Header.Set("Content-MD5", *req.ContentMD5)
	}

	if req.GrantFullControl != nil {
		httpReq.Header.Set("x-amz-grant-full-control", *req.GrantFullControl)
	}

	if req.GrantRead != nil {
		httpReq.Header.Set("x-amz-grant-read", *req.GrantRead)
	}

	if req.GrantReadACP != nil {
		httpReq.Header.Set("x-amz-grant-read-acp", *req.GrantReadACP)
	}

	if req.GrantWrite != nil {
		httpReq.Header.Set("x-amz-grant-write", *req.GrantWrite)
	}

	if req.GrantWriteACP != nil {
		httpReq.Header.Set("x-amz-grant-write-acp", *req.GrantWriteACP)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()

	return
}

// RestoreObject restores an archived copy of an object back into Amazon S3
func (c *S3) RestoreObject(req *RestoreObjectRequest) (err error) {
	// NRE

	var body io.Reader
	var contentType string

	contentType = "application/xml"
	b, err := xml.Marshal(req.RestoreRequest)
	if err != nil {
		return
	}
	body = bytes.NewReader(b)

	uri := c.client.Endpoint + "/{Bucket}/{Key+}?restore"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	if req.Key != nil {
		uri = strings.Replace(uri, "{"+"Key"+"}", *req.Key, -1)
		uri = strings.Replace(uri, "{"+"Key+"+"}", *req.Key, -1)
	}

	q := url.Values{}

	if req.VersionID != nil {
		q.Set("versionId", *req.VersionID)
	}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("POST", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()

	return
}

// UploadPart uploads a part in a multipart upload. Note: After you
// initiate multipart upload and upload one or more parts, you must either
// complete or abort multipart upload in order to stop getting charged for
// storage of the uploaded parts. Only after you either complete or abort
// multipart upload, Amazon S3 frees up the parts storage and stops
// charging you for the parts storage.
func (c *S3) UploadPart(req *UploadPartRequest) (resp *UploadPartOutput, err error) {
	resp = &UploadPartOutput{}

	var body io.Reader
	var contentType string

	body = req.Body

	uri := c.client.Endpoint + "/{Bucket}/{Key+}"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	if req.Key != nil {
		uri = strings.Replace(uri, "{"+"Key"+"}", *req.Key, -1)
		uri = strings.Replace(uri, "{"+"Key+"+"}", *req.Key, -1)
	}

	q := url.Values{}

	if req.PartNumber != nil {
		q.Set("partNumber", strconv.Itoa(*req.PartNumber))
	}

	if req.UploadID != nil {
		q.Set("uploadId", *req.UploadID)
	}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("PUT", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	if req.ContentLength != nil {
		httpReq.ContentLength = int64(*req.ContentLength)
	}

	if req.ContentMD5 != nil {
		httpReq.Header.Set("Content-MD5", *req.ContentMD5)
	}

	if req.SSECustomerAlgorithm != nil {
		httpReq.Header.Set("x-amz-server-side-encryption-customer-algorithm", *req.SSECustomerAlgorithm)
	}

	if req.SSECustomerKey != nil {
		httpReq.Header.Set("x-amz-server-side-encryption-customer-key", *req.SSECustomerKey)
	}

	if req.SSECustomerKeyMD5 != nil {
		httpReq.Header.Set("x-amz-server-side-encryption-customer-key-MD5", *req.SSECustomerKeyMD5)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("ETag"); s != "" {

		resp.ETag = &s

	}

	if s := httpResp.Header.Get("x-amz-server-side-encryption-customer-algorithm"); s != "" {

		resp.SSECustomerAlgorithm = &s

	}

	if s := httpResp.Header.Get("x-amz-server-side-encryption-customer-key-MD5"); s != "" {

		resp.SSECustomerKeyMD5 = &s

	}

	if s := httpResp.Header.Get("x-amz-server-side-encryption-aws-kms-key-id"); s != "" {

		resp.SSEKMSKeyID = &s

	}

	if s := httpResp.Header.Get("x-amz-server-side-encryption"); s != "" {

		resp.ServerSideEncryption = &s

	}

	return
}

// UploadPartCopy uploads a part by copying data from an existing object as
// data source.
func (c *S3) UploadPartCopy(req *UploadPartCopyRequest) (resp *UploadPartCopyOutput, err error) {
	resp = &UploadPartCopyOutput{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/{Bucket}/{Key+}"

	if req.Bucket != nil {
		uri = strings.Replace(uri, "{"+"Bucket"+"}", *req.Bucket, -1)
		uri = strings.Replace(uri, "{"+"Bucket+"+"}", *req.Bucket, -1)
	}

	if req.Key != nil {
		uri = strings.Replace(uri, "{"+"Key"+"}", *req.Key, -1)
		uri = strings.Replace(uri, "{"+"Key+"+"}", *req.Key, -1)
	}

	q := url.Values{}

	if req.PartNumber != nil {
		q.Set("partNumber", strconv.Itoa(*req.PartNumber))
	}

	if req.UploadID != nil {
		q.Set("uploadId", *req.UploadID)
	}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("PUT", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	if req.CopySource != nil {
		httpReq.Header.Set("x-amz-copy-source", *req.CopySource)
	}

	if req.CopySourceIfMatch != nil {
		httpReq.Header.Set("x-amz-copy-source-if-match", *req.CopySourceIfMatch)
	}

	if req.CopySourceIfModifiedSince != (time.Time{}) {
		httpReq.Header.Set("x-amz-copy-source-if-modified-since", req.CopySourceIfModifiedSince.Format(time.RFC822))
	}

	if req.CopySourceIfNoneMatch != nil {
		httpReq.Header.Set("x-amz-copy-source-if-none-match", *req.CopySourceIfNoneMatch)
	}

	if req.CopySourceIfUnmodifiedSince != (time.Time{}) {
		httpReq.Header.Set("x-amz-copy-source-if-unmodified-since", req.CopySourceIfUnmodifiedSince.Format(time.RFC822))
	}

	if req.CopySourceRange != nil {
		httpReq.Header.Set("x-amz-copy-source-range", *req.CopySourceRange)
	}

	if req.CopySourceSSECustomerAlgorithm != nil {
		httpReq.Header.Set("x-amz-copy-source-server-side-encryption-customer-algorithm", *req.CopySourceSSECustomerAlgorithm)
	}

	if req.CopySourceSSECustomerKey != nil {
		httpReq.Header.Set("x-amz-copy-source-server-side-encryption-customer-key", *req.CopySourceSSECustomerKey)
	}

	if req.CopySourceSSECustomerKeyMD5 != nil {
		httpReq.Header.Set("x-amz-copy-source-server-side-encryption-customer-key-MD5", *req.CopySourceSSECustomerKeyMD5)
	}

	if req.SSECustomerAlgorithm != nil {
		httpReq.Header.Set("x-amz-server-side-encryption-customer-algorithm", *req.SSECustomerAlgorithm)
	}

	if req.SSECustomerKey != nil {
		httpReq.Header.Set("x-amz-server-side-encryption-customer-key", *req.SSECustomerKey)
	}

	if req.SSECustomerKeyMD5 != nil {
		httpReq.Header.Set("x-amz-server-side-encryption-customer-key-MD5", *req.SSECustomerKeyMD5)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("x-amz-copy-source-version-id"); s != "" {

		resp.CopySourceVersionID = &s

	}

	if s := httpResp.Header.Get("x-amz-server-side-encryption-customer-algorithm"); s != "" {

		resp.SSECustomerAlgorithm = &s

	}

	if s := httpResp.Header.Get("x-amz-server-side-encryption-customer-key-MD5"); s != "" {

		resp.SSECustomerKeyMD5 = &s

	}

	if s := httpResp.Header.Get("x-amz-server-side-encryption-aws-kms-key-id"); s != "" {

		resp.SSEKMSKeyID = &s

	}

	if s := httpResp.Header.Get("x-amz-server-side-encryption"); s != "" {

		resp.ServerSideEncryption = &s

	}

	return
}

// AbortMultipartUploadRequest is undocumented.
type AbortMultipartUploadRequest struct {
	Bucket   aws.StringValue `xml:"Bucket"`
	Key      aws.StringValue `xml:"Key"`
	UploadID aws.StringValue `xml:"uploadId"`
}

// AccessControlPolicy is undocumented.
type AccessControlPolicy struct {
	Grants []Grant `xml:"AccessControlList"`
	Owner  *Owner  `xml:"Owner"`
}

// Bucket is undocumented.
type Bucket struct {
	CreationDate time.Time       `xml:"CreationDate"`
	Name         aws.StringValue `xml:"Name"`
}

// BucketLoggingStatus is undocumented.
type BucketLoggingStatus struct {
	LoggingEnabled *LoggingEnabled `xml:"LoggingEnabled"`
}

// CORSConfiguration is undocumented.
type CORSConfiguration struct {
	CORSRules []CORSRule `xml:"CORSRule"`
}

// CORSRule is undocumented.
type CORSRule struct {
	AllowedHeaders []string         `xml:"AllowedHeader"`
	AllowedMethods []string         `xml:"AllowedMethod"`
	AllowedOrigins []string         `xml:"AllowedOrigin"`
	ExposeHeaders  []string         `xml:"ExposeHeader"`
	MaxAgeSeconds  aws.IntegerValue `xml:"MaxAgeSeconds"`
}

// CloudFunctionConfiguration is undocumented.
type CloudFunctionConfiguration struct {
	CloudFunction  aws.StringValue `xml:"CloudFunction"`
	Event          aws.StringValue `xml:"Event"`
	Events         []string        `xml:"Event"`
	ID             aws.StringValue `xml:"Id"`
	InvocationRole aws.StringValue `xml:"InvocationRole"`
}

// CommonPrefix is undocumented.
type CommonPrefix struct {
	Prefix aws.StringValue `xml:"Prefix"`
}

// CompleteMultipartUploadOutput is undocumented.
type CompleteMultipartUploadOutput struct {
	Bucket               aws.StringValue `xml:"Bucket"`
	ETag                 aws.StringValue `xml:"ETag"`
	Expiration           time.Time       `xml:"x-amz-expiration"`
	Key                  aws.StringValue `xml:"Key"`
	Location             aws.StringValue `xml:"Location"`
	SSEKMSKeyID          aws.StringValue `xml:"x-amz-server-side-encryption-aws-kms-key-id"`
	ServerSideEncryption aws.StringValue `xml:"x-amz-server-side-encryption"`
	VersionID            aws.StringValue `xml:"x-amz-version-id"`
}

// CompleteMultipartUploadRequest is undocumented.
type CompleteMultipartUploadRequest struct {
	Bucket          aws.StringValue           `xml:"Bucket"`
	Key             aws.StringValue           `xml:"Key"`
	MultipartUpload *CompletedMultipartUpload `xml:"CompleteMultipartUpload"`
	UploadID        aws.StringValue           `xml:"uploadId"`
}

// CompletedMultipartUpload is undocumented.
type CompletedMultipartUpload struct {
	Parts []CompletedPart `xml:"Part"`
}

// CompletedPart is undocumented.
type CompletedPart struct {
	ETag       aws.StringValue  `xml:"ETag"`
	PartNumber aws.IntegerValue `xml:"PartNumber"`
}

// Condition is undocumented.
type Condition struct {
	HTTPErrorCodeReturnedEquals aws.StringValue `xml:"HttpErrorCodeReturnedEquals"`
	KeyPrefixEquals             aws.StringValue `xml:"KeyPrefixEquals"`
}

// CopyObjectOutput is undocumented.
type CopyObjectOutput struct {
	CopyObjectResult     *CopyObjectResult `xml:"CopyObjectResult"`
	CopySourceVersionID  aws.StringValue   `xml:"x-amz-copy-source-version-id"`
	Expiration           time.Time         `xml:"x-amz-expiration"`
	SSECustomerAlgorithm aws.StringValue   `xml:"x-amz-server-side-encryption-customer-algorithm"`
	SSECustomerKeyMD5    aws.StringValue   `xml:"x-amz-server-side-encryption-customer-key-MD5"`
	SSEKMSKeyID          aws.StringValue   `xml:"x-amz-server-side-encryption-aws-kms-key-id"`
	ServerSideEncryption aws.StringValue   `xml:"x-amz-server-side-encryption"`
}

// CopyObjectRequest is undocumented.
type CopyObjectRequest struct {
	ACL                            aws.StringValue   `xml:"x-amz-acl"`
	Bucket                         aws.StringValue   `xml:"Bucket"`
	CacheControl                   aws.StringValue   `xml:"Cache-Control"`
	ContentDisposition             aws.StringValue   `xml:"Content-Disposition"`
	ContentEncoding                aws.StringValue   `xml:"Content-Encoding"`
	ContentLanguage                aws.StringValue   `xml:"Content-Language"`
	ContentType                    aws.StringValue   `xml:"Content-Type"`
	CopySource                     aws.StringValue   `xml:"x-amz-copy-source"`
	CopySourceIfMatch              aws.StringValue   `xml:"x-amz-copy-source-if-match"`
	CopySourceIfModifiedSince      time.Time         `xml:"x-amz-copy-source-if-modified-since"`
	CopySourceIfNoneMatch          aws.StringValue   `xml:"x-amz-copy-source-if-none-match"`
	CopySourceIfUnmodifiedSince    time.Time         `xml:"x-amz-copy-source-if-unmodified-since"`
	CopySourceSSECustomerAlgorithm aws.StringValue   `xml:"x-amz-copy-source-server-side-encryption-customer-algorithm"`
	CopySourceSSECustomerKey       aws.StringValue   `xml:"x-amz-copy-source-server-side-encryption-customer-key"`
	CopySourceSSECustomerKeyMD5    aws.StringValue   `xml:"x-amz-copy-source-server-side-encryption-customer-key-MD5"`
	Expires                        time.Time         `xml:"Expires"`
	GrantFullControl               aws.StringValue   `xml:"x-amz-grant-full-control"`
	GrantRead                      aws.StringValue   `xml:"x-amz-grant-read"`
	GrantReadACP                   aws.StringValue   `xml:"x-amz-grant-read-acp"`
	GrantWriteACP                  aws.StringValue   `xml:"x-amz-grant-write-acp"`
	Key                            aws.StringValue   `xml:"Key"`
	Metadata                       map[string]string `xml:"x-amz-meta-"`
	MetadataDirective              aws.StringValue   `xml:"x-amz-metadata-directive"`
	SSECustomerAlgorithm           aws.StringValue   `xml:"x-amz-server-side-encryption-customer-algorithm"`
	SSECustomerKey                 aws.StringValue   `xml:"x-amz-server-side-encryption-customer-key"`
	SSECustomerKeyMD5              aws.StringValue   `xml:"x-amz-server-side-encryption-customer-key-MD5"`
	SSEKMSKeyID                    aws.StringValue   `xml:"x-amz-server-side-encryption-aws-kms-key-id"`
	ServerSideEncryption           aws.StringValue   `xml:"x-amz-server-side-encryption"`
	StorageClass                   aws.StringValue   `xml:"x-amz-storage-class"`
	WebsiteRedirectLocation        aws.StringValue   `xml:"x-amz-website-redirect-location"`
}

// CopyObjectResult is undocumented.
type CopyObjectResult struct {
	ETag         aws.StringValue `xml:"ETag"`
	LastModified time.Time       `xml:"LastModified"`
}

// CopyPartResult is undocumented.
type CopyPartResult struct {
	ETag         aws.StringValue `xml:"ETag"`
	LastModified time.Time       `xml:"LastModified"`
}

// CreateBucketConfiguration is undocumented.
type CreateBucketConfiguration struct {
	LocationConstraint aws.StringValue `xml:"LocationConstraint"`
}

// CreateBucketOutput is undocumented.
type CreateBucketOutput struct {
	Location aws.StringValue `xml:"Location"`
}

// CreateBucketRequest is undocumented.
type CreateBucketRequest struct {
	ACL                       aws.StringValue            `xml:"x-amz-acl"`
	Bucket                    aws.StringValue            `xml:"Bucket"`
	CreateBucketConfiguration *CreateBucketConfiguration `xml:"CreateBucketConfiguration"`
	GrantFullControl          aws.StringValue            `xml:"x-amz-grant-full-control"`
	GrantRead                 aws.StringValue            `xml:"x-amz-grant-read"`
	GrantReadACP              aws.StringValue            `xml:"x-amz-grant-read-acp"`
	GrantWrite                aws.StringValue            `xml:"x-amz-grant-write"`
	GrantWriteACP             aws.StringValue            `xml:"x-amz-grant-write-acp"`
}

// CreateMultipartUploadOutput is undocumented.
type CreateMultipartUploadOutput struct {
	Bucket               aws.StringValue `xml:"Bucket"`
	Key                  aws.StringValue `xml:"Key"`
	SSECustomerAlgorithm aws.StringValue `xml:"x-amz-server-side-encryption-customer-algorithm"`
	SSECustomerKeyMD5    aws.StringValue `xml:"x-amz-server-side-encryption-customer-key-MD5"`
	SSEKMSKeyID          aws.StringValue `xml:"x-amz-server-side-encryption-aws-kms-key-id"`
	ServerSideEncryption aws.StringValue `xml:"x-amz-server-side-encryption"`
	UploadID             aws.StringValue `xml:"UploadId"`
}

// CreateMultipartUploadRequest is undocumented.
type CreateMultipartUploadRequest struct {
	ACL                     aws.StringValue   `xml:"x-amz-acl"`
	Bucket                  aws.StringValue   `xml:"Bucket"`
	CacheControl            aws.StringValue   `xml:"Cache-Control"`
	ContentDisposition      aws.StringValue   `xml:"Content-Disposition"`
	ContentEncoding         aws.StringValue   `xml:"Content-Encoding"`
	ContentLanguage         aws.StringValue   `xml:"Content-Language"`
	ContentType             aws.StringValue   `xml:"Content-Type"`
	Expires                 time.Time         `xml:"Expires"`
	GrantFullControl        aws.StringValue   `xml:"x-amz-grant-full-control"`
	GrantRead               aws.StringValue   `xml:"x-amz-grant-read"`
	GrantReadACP            aws.StringValue   `xml:"x-amz-grant-read-acp"`
	GrantWriteACP           aws.StringValue   `xml:"x-amz-grant-write-acp"`
	Key                     aws.StringValue   `xml:"Key"`
	Metadata                map[string]string `xml:"x-amz-meta-"`
	SSECustomerAlgorithm    aws.StringValue   `xml:"x-amz-server-side-encryption-customer-algorithm"`
	SSECustomerKey          aws.StringValue   `xml:"x-amz-server-side-encryption-customer-key"`
	SSECustomerKeyMD5       aws.StringValue   `xml:"x-amz-server-side-encryption-customer-key-MD5"`
	SSEKMSKeyID             aws.StringValue   `xml:"x-amz-server-side-encryption-aws-kms-key-id"`
	ServerSideEncryption    aws.StringValue   `xml:"x-amz-server-side-encryption"`
	StorageClass            aws.StringValue   `xml:"x-amz-storage-class"`
	WebsiteRedirectLocation aws.StringValue   `xml:"x-amz-website-redirect-location"`
}

// Delete is undocumented.
type Delete struct {
	Objects []ObjectIdentifier `xml:"Object"`
	Quiet   aws.BooleanValue   `xml:"Quiet"`
}

// DeleteBucketCorsRequest is undocumented.
type DeleteBucketCorsRequest struct {
	Bucket aws.StringValue `xml:"Bucket"`
}

// DeleteBucketLifecycleRequest is undocumented.
type DeleteBucketLifecycleRequest struct {
	Bucket aws.StringValue `xml:"Bucket"`
}

// DeleteBucketPolicyRequest is undocumented.
type DeleteBucketPolicyRequest struct {
	Bucket aws.StringValue `xml:"Bucket"`
}

// DeleteBucketRequest is undocumented.
type DeleteBucketRequest struct {
	Bucket aws.StringValue `xml:"Bucket"`
}

// DeleteBucketTaggingRequest is undocumented.
type DeleteBucketTaggingRequest struct {
	Bucket aws.StringValue `xml:"Bucket"`
}

// DeleteBucketWebsiteRequest is undocumented.
type DeleteBucketWebsiteRequest struct {
	Bucket aws.StringValue `xml:"Bucket"`
}

// DeleteMarkerEntry is undocumented.
type DeleteMarkerEntry struct {
	IsLatest     aws.BooleanValue `xml:"IsLatest"`
	Key          aws.StringValue  `xml:"Key"`
	LastModified time.Time        `xml:"LastModified"`
	Owner        *Owner           `xml:"Owner"`
	VersionID    aws.StringValue  `xml:"VersionId"`
}

// DeleteObjectOutput is undocumented.
type DeleteObjectOutput struct {
	DeleteMarker aws.BooleanValue `xml:"x-amz-delete-marker"`
	VersionID    aws.StringValue  `xml:"x-amz-version-id"`
}

// DeleteObjectRequest is undocumented.
type DeleteObjectRequest struct {
	Bucket    aws.StringValue `xml:"Bucket"`
	Key       aws.StringValue `xml:"Key"`
	MFA       aws.StringValue `xml:"x-amz-mfa"`
	VersionID aws.StringValue `xml:"versionId"`
}

// DeleteObjectsOutput is undocumented.
type DeleteObjectsOutput struct {
	Deleted []DeletedObject `xml:"Deleted"`
	Errors  []Error         `xml:"Error"`
}

// DeleteObjectsRequest is undocumented.
type DeleteObjectsRequest struct {
	Bucket aws.StringValue `xml:"Bucket"`
	Delete *Delete         `xml:"Delete"`
	MFA    aws.StringValue `xml:"x-amz-mfa"`
}

// DeletedObject is undocumented.
type DeletedObject struct {
	DeleteMarker          aws.BooleanValue `xml:"DeleteMarker"`
	DeleteMarkerVersionID aws.StringValue  `xml:"DeleteMarkerVersionId"`
	Key                   aws.StringValue  `xml:"Key"`
	VersionID             aws.StringValue  `xml:"VersionId"`
}

// Error is undocumented.
type Error struct {
	Code      aws.StringValue `xml:"Code"`
	Key       aws.StringValue `xml:"Key"`
	Message   aws.StringValue `xml:"Message"`
	VersionID aws.StringValue `xml:"VersionId"`
}

// ErrorDocument is undocumented.
type ErrorDocument struct {
	Key aws.StringValue `xml:"Key"`
}

// GetBucketAclOutput is undocumented.
type GetBucketAclOutput struct {
	Grants []Grant `xml:"AccessControlList"`
	Owner  *Owner  `xml:"Owner"`
}

// GetBucketAclRequest is undocumented.
type GetBucketAclRequest struct {
	Bucket aws.StringValue `xml:"Bucket"`
}

// GetBucketCorsOutput is undocumented.
type GetBucketCorsOutput struct {
	CORSRules []CORSRule `xml:"CORSRule"`
}

// GetBucketCorsRequest is undocumented.
type GetBucketCorsRequest struct {
	Bucket aws.StringValue `xml:"Bucket"`
}

// GetBucketLifecycleOutput is undocumented.
type GetBucketLifecycleOutput struct {
	Rules []Rule `xml:"Rule"`
}

// GetBucketLifecycleRequest is undocumented.
type GetBucketLifecycleRequest struct {
	Bucket aws.StringValue `xml:"Bucket"`
}

// GetBucketLocationOutput is undocumented.
type GetBucketLocationOutput struct {
	LocationConstraint aws.StringValue `xml:"LocationConstraint"`
}

// GetBucketLocationRequest is undocumented.
type GetBucketLocationRequest struct {
	Bucket aws.StringValue `xml:"Bucket"`
}

// GetBucketLoggingOutput is undocumented.
type GetBucketLoggingOutput struct {
	LoggingEnabled *LoggingEnabled `xml:"LoggingEnabled"`
}

// GetBucketLoggingRequest is undocumented.
type GetBucketLoggingRequest struct {
	Bucket aws.StringValue `xml:"Bucket"`
}

// GetBucketNotificationOutput is undocumented.
type GetBucketNotificationOutput struct {
	CloudFunctionConfiguration *CloudFunctionConfiguration `xml:"CloudFunctionConfiguration"`
	QueueConfiguration         *QueueConfiguration         `xml:"QueueConfiguration"`
	TopicConfiguration         *TopicConfiguration         `xml:"TopicConfiguration"`
}

// GetBucketNotificationRequest is undocumented.
type GetBucketNotificationRequest struct {
	Bucket aws.StringValue `xml:"Bucket"`
}

// GetBucketPolicyOutput is undocumented.
type GetBucketPolicyOutput struct {
	Policy aws.StringValue `xml:"Policy"`
}

// GetBucketPolicyRequest is undocumented.
type GetBucketPolicyRequest struct {
	Bucket aws.StringValue `xml:"Bucket"`
}

// GetBucketRequestPaymentOutput is undocumented.
type GetBucketRequestPaymentOutput struct {
	Payer aws.StringValue `xml:"Payer"`
}

// GetBucketRequestPaymentRequest is undocumented.
type GetBucketRequestPaymentRequest struct {
	Bucket aws.StringValue `xml:"Bucket"`
}

// GetBucketTaggingOutput is undocumented.
type GetBucketTaggingOutput struct {
	TagSet []Tag `xml:"TagSet"`
}

// GetBucketTaggingRequest is undocumented.
type GetBucketTaggingRequest struct {
	Bucket aws.StringValue `xml:"Bucket"`
}

// GetBucketVersioningOutput is undocumented.
type GetBucketVersioningOutput struct {
	MFADelete aws.StringValue `xml:"MfaDelete"`
	Status    aws.StringValue `xml:"Status"`
}

// GetBucketVersioningRequest is undocumented.
type GetBucketVersioningRequest struct {
	Bucket aws.StringValue `xml:"Bucket"`
}

// GetBucketWebsiteOutput is undocumented.
type GetBucketWebsiteOutput struct {
	ErrorDocument         *ErrorDocument         `xml:"ErrorDocument"`
	IndexDocument         *IndexDocument         `xml:"IndexDocument"`
	RedirectAllRequestsTo *RedirectAllRequestsTo `xml:"RedirectAllRequestsTo"`
	RoutingRules          []RoutingRule          `xml:"RoutingRules"`
}

// GetBucketWebsiteRequest is undocumented.
type GetBucketWebsiteRequest struct {
	Bucket aws.StringValue `xml:"Bucket"`
}

// GetObjectAclOutput is undocumented.
type GetObjectAclOutput struct {
	Grants []Grant `xml:"AccessControlList"`
	Owner  *Owner  `xml:"Owner"`
}

// GetObjectAclRequest is undocumented.
type GetObjectAclRequest struct {
	Bucket    aws.StringValue `xml:"Bucket"`
	Key       aws.StringValue `xml:"Key"`
	VersionID aws.StringValue `xml:"versionId"`
}

// GetObjectOutput is undocumented.
type GetObjectOutput struct {
	AcceptRanges            aws.StringValue   `xml:"accept-ranges"`
	Body                    io.ReadCloser     `xml:"Body"`
	CacheControl            aws.StringValue   `xml:"Cache-Control"`
	ContentDisposition      aws.StringValue   `xml:"Content-Disposition"`
	ContentEncoding         aws.StringValue   `xml:"Content-Encoding"`
	ContentLanguage         aws.StringValue   `xml:"Content-Language"`
	ContentLength           aws.IntegerValue  `xml:"Content-Length"`
	ContentType             aws.StringValue   `xml:"Content-Type"`
	DeleteMarker            aws.BooleanValue  `xml:"x-amz-delete-marker"`
	ETag                    aws.StringValue   `xml:"ETag"`
	Expiration              time.Time         `xml:"x-amz-expiration"`
	Expires                 time.Time         `xml:"Expires"`
	LastModified            time.Time         `xml:"Last-Modified"`
	Metadata                map[string]string `xml:"x-amz-meta-"`
	MissingMeta             aws.IntegerValue  `xml:"x-amz-missing-meta"`
	Restore                 aws.StringValue   `xml:"x-amz-restore"`
	SSECustomerAlgorithm    aws.StringValue   `xml:"x-amz-server-side-encryption-customer-algorithm"`
	SSECustomerKeyMD5       aws.StringValue   `xml:"x-amz-server-side-encryption-customer-key-MD5"`
	SSEKMSKeyID             aws.StringValue   `xml:"x-amz-server-side-encryption-aws-kms-key-id"`
	ServerSideEncryption    aws.StringValue   `xml:"x-amz-server-side-encryption"`
	VersionID               aws.StringValue   `xml:"x-amz-version-id"`
	WebsiteRedirectLocation aws.StringValue   `xml:"x-amz-website-redirect-location"`
}

// GetObjectRequest is undocumented.
type GetObjectRequest struct {
	Bucket                     aws.StringValue `xml:"Bucket"`
	IfMatch                    aws.StringValue `xml:"If-Match"`
	IfModifiedSince            time.Time       `xml:"If-Modified-Since"`
	IfNoneMatch                aws.StringValue `xml:"If-None-Match"`
	IfUnmodifiedSince          time.Time       `xml:"If-Unmodified-Since"`
	Key                        aws.StringValue `xml:"Key"`
	Range                      aws.StringValue `xml:"Range"`
	ResponseCacheControl       aws.StringValue `xml:"response-cache-control"`
	ResponseContentDisposition aws.StringValue `xml:"response-content-disposition"`
	ResponseContentEncoding    aws.StringValue `xml:"response-content-encoding"`
	ResponseContentLanguage    aws.StringValue `xml:"response-content-language"`
	ResponseContentType        aws.StringValue `xml:"response-content-type"`
	ResponseExpires            time.Time       `xml:"response-expires"`
	SSECustomerAlgorithm       aws.StringValue `xml:"x-amz-server-side-encryption-customer-algorithm"`
	SSECustomerKey             aws.StringValue `xml:"x-amz-server-side-encryption-customer-key"`
	SSECustomerKeyMD5          aws.StringValue `xml:"x-amz-server-side-encryption-customer-key-MD5"`
	VersionID                  aws.StringValue `xml:"versionId"`
}

// GetObjectTorrentOutput is undocumented.
type GetObjectTorrentOutput struct {
	Body io.ReadCloser `xml:"Body"`
}

// GetObjectTorrentRequest is undocumented.
type GetObjectTorrentRequest struct {
	Bucket aws.StringValue `xml:"Bucket"`
	Key    aws.StringValue `xml:"Key"`
}

// Grant is undocumented.
type Grant struct {
	Grantee    *Grantee        `xml:"Grantee"`
	Permission aws.StringValue `xml:"Permission"`
}

// Grantee is undocumented.
type Grantee struct {
	DisplayName  aws.StringValue `xml:"DisplayName"`
	EmailAddress aws.StringValue `xml:"EmailAddress"`
	ID           aws.StringValue `xml:"ID"`
	Type         aws.StringValue `xml:"Type"`
	URI          aws.StringValue `xml:"URI"`
}

// HeadBucketRequest is undocumented.
type HeadBucketRequest struct {
	Bucket aws.StringValue `xml:"Bucket"`
}

// HeadObjectOutput is undocumented.
type HeadObjectOutput struct {
	AcceptRanges            aws.StringValue   `xml:"accept-ranges"`
	CacheControl            aws.StringValue   `xml:"Cache-Control"`
	ContentDisposition      aws.StringValue   `xml:"Content-Disposition"`
	ContentEncoding         aws.StringValue   `xml:"Content-Encoding"`
	ContentLanguage         aws.StringValue   `xml:"Content-Language"`
	ContentLength           aws.IntegerValue  `xml:"Content-Length"`
	ContentType             aws.StringValue   `xml:"Content-Type"`
	DeleteMarker            aws.BooleanValue  `xml:"x-amz-delete-marker"`
	ETag                    aws.StringValue   `xml:"ETag"`
	Expiration              time.Time         `xml:"x-amz-expiration"`
	Expires                 time.Time         `xml:"Expires"`
	LastModified            time.Time         `xml:"Last-Modified"`
	Metadata                map[string]string `xml:"x-amz-meta-"`
	MissingMeta             aws.IntegerValue  `xml:"x-amz-missing-meta"`
	Restore                 aws.StringValue   `xml:"x-amz-restore"`
	SSECustomerAlgorithm    aws.StringValue   `xml:"x-amz-server-side-encryption-customer-algorithm"`
	SSECustomerKeyMD5       aws.StringValue   `xml:"x-amz-server-side-encryption-customer-key-MD5"`
	SSEKMSKeyID             aws.StringValue   `xml:"x-amz-server-side-encryption-aws-kms-key-id"`
	ServerSideEncryption    aws.StringValue   `xml:"x-amz-server-side-encryption"`
	VersionID               aws.StringValue   `xml:"x-amz-version-id"`
	WebsiteRedirectLocation aws.StringValue   `xml:"x-amz-website-redirect-location"`
}

// HeadObjectRequest is undocumented.
type HeadObjectRequest struct {
	Bucket               aws.StringValue `xml:"Bucket"`
	IfMatch              aws.StringValue `xml:"If-Match"`
	IfModifiedSince      time.Time       `xml:"If-Modified-Since"`
	IfNoneMatch          aws.StringValue `xml:"If-None-Match"`
	IfUnmodifiedSince    time.Time       `xml:"If-Unmodified-Since"`
	Key                  aws.StringValue `xml:"Key"`
	Range                aws.StringValue `xml:"Range"`
	SSECustomerAlgorithm aws.StringValue `xml:"x-amz-server-side-encryption-customer-algorithm"`
	SSECustomerKey       aws.StringValue `xml:"x-amz-server-side-encryption-customer-key"`
	SSECustomerKeyMD5    aws.StringValue `xml:"x-amz-server-side-encryption-customer-key-MD5"`
	VersionID            aws.StringValue `xml:"versionId"`
}

// IndexDocument is undocumented.
type IndexDocument struct {
	Suffix aws.StringValue `xml:"Suffix"`
}

// Initiator is undocumented.
type Initiator struct {
	DisplayName aws.StringValue `xml:"DisplayName"`
	ID          aws.StringValue `xml:"ID"`
}

// LifecycleConfiguration is undocumented.
type LifecycleConfiguration struct {
	Rules []Rule `xml:"Rule"`
}

// LifecycleExpiration is undocumented.
type LifecycleExpiration struct {
	Date time.Time        `xml:"Date"`
	Days aws.IntegerValue `xml:"Days"`
}

// ListBucketsOutput is undocumented.
type ListBucketsOutput struct {
	Buckets []Bucket `xml:"Buckets"`
	Owner   *Owner   `xml:"Owner"`
}

// ListMultipartUploadsOutput is undocumented.
type ListMultipartUploadsOutput struct {
	Bucket             aws.StringValue   `xml:"Bucket"`
	CommonPrefixes     []CommonPrefix    `xml:"CommonPrefixes"`
	Delimiter          aws.StringValue   `xml:"Delimiter"`
	EncodingType       aws.StringValue   `xml:"EncodingType"`
	IsTruncated        aws.BooleanValue  `xml:"IsTruncated"`
	KeyMarker          aws.StringValue   `xml:"KeyMarker"`
	MaxUploads         aws.IntegerValue  `xml:"MaxUploads"`
	NextKeyMarker      aws.StringValue   `xml:"NextKeyMarker"`
	NextUploadIDMarker aws.StringValue   `xml:"NextUploadIdMarker"`
	Prefix             aws.StringValue   `xml:"Prefix"`
	UploadIDMarker     aws.StringValue   `xml:"UploadIdMarker"`
	Uploads            []MultipartUpload `xml:"Upload"`
}

// ListMultipartUploadsRequest is undocumented.
type ListMultipartUploadsRequest struct {
	Bucket         aws.StringValue  `xml:"Bucket"`
	Delimiter      aws.StringValue  `xml:"delimiter"`
	EncodingType   aws.StringValue  `xml:"encoding-type"`
	KeyMarker      aws.StringValue  `xml:"key-marker"`
	MaxUploads     aws.IntegerValue `xml:"max-uploads"`
	Prefix         aws.StringValue  `xml:"prefix"`
	UploadIDMarker aws.StringValue  `xml:"upload-id-marker"`
}

// ListObjectVersionsOutput is undocumented.
type ListObjectVersionsOutput struct {
	CommonPrefixes      []CommonPrefix      `xml:"CommonPrefixes"`
	DeleteMarkers       []DeleteMarkerEntry `xml:"DeleteMarker"`
	Delimiter           aws.StringValue     `xml:"Delimiter"`
	EncodingType        aws.StringValue     `xml:"EncodingType"`
	IsTruncated         aws.BooleanValue    `xml:"IsTruncated"`
	KeyMarker           aws.StringValue     `xml:"KeyMarker"`
	MaxKeys             aws.IntegerValue    `xml:"MaxKeys"`
	Name                aws.StringValue     `xml:"Name"`
	NextKeyMarker       aws.StringValue     `xml:"NextKeyMarker"`
	NextVersionIDMarker aws.StringValue     `xml:"NextVersionIdMarker"`
	Prefix              aws.StringValue     `xml:"Prefix"`
	VersionIDMarker     aws.StringValue     `xml:"VersionIdMarker"`
	Versions            []ObjectVersion     `xml:"Version"`
}

// ListObjectVersionsRequest is undocumented.
type ListObjectVersionsRequest struct {
	Bucket          aws.StringValue  `xml:"Bucket"`
	Delimiter       aws.StringValue  `xml:"delimiter"`
	EncodingType    aws.StringValue  `xml:"encoding-type"`
	KeyMarker       aws.StringValue  `xml:"key-marker"`
	MaxKeys         aws.IntegerValue `xml:"max-keys"`
	Prefix          aws.StringValue  `xml:"prefix"`
	VersionIDMarker aws.StringValue  `xml:"version-id-marker"`
}

// ListObjectsOutput is undocumented.
type ListObjectsOutput struct {
	CommonPrefixes []CommonPrefix   `xml:"CommonPrefixes"`
	Contents       []Object         `xml:"Contents"`
	Delimiter      aws.StringValue  `xml:"Delimiter"`
	EncodingType   aws.StringValue  `xml:"EncodingType"`
	IsTruncated    aws.BooleanValue `xml:"IsTruncated"`
	Marker         aws.StringValue  `xml:"Marker"`
	MaxKeys        aws.IntegerValue `xml:"MaxKeys"`
	Name           aws.StringValue  `xml:"Name"`
	NextMarker     aws.StringValue  `xml:"NextMarker"`
	Prefix         aws.StringValue  `xml:"Prefix"`
}

// ListObjectsRequest is undocumented.
type ListObjectsRequest struct {
	Bucket       aws.StringValue  `xml:"Bucket"`
	Delimiter    aws.StringValue  `xml:"delimiter"`
	EncodingType aws.StringValue  `xml:"encoding-type"`
	Marker       aws.StringValue  `xml:"marker"`
	MaxKeys      aws.IntegerValue `xml:"max-keys"`
	Prefix       aws.StringValue  `xml:"prefix"`
}

// ListPartsOutput is undocumented.
type ListPartsOutput struct {
	Bucket               aws.StringValue  `xml:"Bucket"`
	Initiator            *Initiator       `xml:"Initiator"`
	IsTruncated          aws.BooleanValue `xml:"IsTruncated"`
	Key                  aws.StringValue  `xml:"Key"`
	MaxParts             aws.IntegerValue `xml:"MaxParts"`
	NextPartNumberMarker aws.IntegerValue `xml:"NextPartNumberMarker"`
	Owner                *Owner           `xml:"Owner"`
	PartNumberMarker     aws.IntegerValue `xml:"PartNumberMarker"`
	Parts                []Part           `xml:"Part"`
	StorageClass         aws.StringValue  `xml:"StorageClass"`
	UploadID             aws.StringValue  `xml:"UploadId"`
}

// ListPartsRequest is undocumented.
type ListPartsRequest struct {
	Bucket           aws.StringValue  `xml:"Bucket"`
	Key              aws.StringValue  `xml:"Key"`
	MaxParts         aws.IntegerValue `xml:"max-parts"`
	PartNumberMarker aws.IntegerValue `xml:"part-number-marker"`
	UploadID         aws.StringValue  `xml:"uploadId"`
}

// LoggingEnabled is undocumented.
type LoggingEnabled struct {
	TargetBucket aws.StringValue `xml:"TargetBucket"`
	TargetGrants []TargetGrant   `xml:"TargetGrants"`
	TargetPrefix aws.StringValue `xml:"TargetPrefix"`
}

// MultipartUpload is undocumented.
type MultipartUpload struct {
	Initiated    time.Time       `xml:"Initiated"`
	Initiator    *Initiator      `xml:"Initiator"`
	Key          aws.StringValue `xml:"Key"`
	Owner        *Owner          `xml:"Owner"`
	StorageClass aws.StringValue `xml:"StorageClass"`
	UploadID     aws.StringValue `xml:"UploadId"`
}

// NoncurrentVersionExpiration is undocumented.
type NoncurrentVersionExpiration struct {
	NoncurrentDays aws.IntegerValue `xml:"NoncurrentDays"`
}

// NoncurrentVersionTransition is undocumented.
type NoncurrentVersionTransition struct {
	NoncurrentDays aws.IntegerValue `xml:"NoncurrentDays"`
	StorageClass   aws.StringValue  `xml:"StorageClass"`
}

// NotificationConfiguration is undocumented.
type NotificationConfiguration struct {
	CloudFunctionConfiguration *CloudFunctionConfiguration `xml:"CloudFunctionConfiguration"`
	QueueConfiguration         *QueueConfiguration         `xml:"QueueConfiguration"`
	TopicConfiguration         *TopicConfiguration         `xml:"TopicConfiguration"`
}

// Object is undocumented.
type Object struct {
	ETag         aws.StringValue  `xml:"ETag"`
	Key          aws.StringValue  `xml:"Key"`
	LastModified time.Time        `xml:"LastModified"`
	Owner        *Owner           `xml:"Owner"`
	Size         aws.IntegerValue `xml:"Size"`
	StorageClass aws.StringValue  `xml:"StorageClass"`
}

// ObjectIdentifier is undocumented.
type ObjectIdentifier struct {
	Key       aws.StringValue `xml:"Key"`
	VersionID aws.StringValue `xml:"VersionId"`
}

// ObjectVersion is undocumented.
type ObjectVersion struct {
	ETag         aws.StringValue  `xml:"ETag"`
	IsLatest     aws.BooleanValue `xml:"IsLatest"`
	Key          aws.StringValue  `xml:"Key"`
	LastModified time.Time        `xml:"LastModified"`
	Owner        *Owner           `xml:"Owner"`
	Size         aws.IntegerValue `xml:"Size"`
	StorageClass aws.StringValue  `xml:"StorageClass"`
	VersionID    aws.StringValue  `xml:"VersionId"`
}

// Owner is undocumented.
type Owner struct {
	DisplayName aws.StringValue `xml:"DisplayName"`
	ID          aws.StringValue `xml:"ID"`
}

// Part is undocumented.
type Part struct {
	ETag         aws.StringValue  `xml:"ETag"`
	LastModified time.Time        `xml:"LastModified"`
	PartNumber   aws.IntegerValue `xml:"PartNumber"`
	Size         aws.IntegerValue `xml:"Size"`
}

// PutBucketAclRequest is undocumented.
type PutBucketAclRequest struct {
	ACL                 aws.StringValue      `xml:"x-amz-acl"`
	AccessControlPolicy *AccessControlPolicy `xml:"AccessControlPolicy"`
	Bucket              aws.StringValue      `xml:"Bucket"`
	ContentMD5          aws.StringValue      `xml:"Content-MD5"`
	GrantFullControl    aws.StringValue      `xml:"x-amz-grant-full-control"`
	GrantRead           aws.StringValue      `xml:"x-amz-grant-read"`
	GrantReadACP        aws.StringValue      `xml:"x-amz-grant-read-acp"`
	GrantWrite          aws.StringValue      `xml:"x-amz-grant-write"`
	GrantWriteACP       aws.StringValue      `xml:"x-amz-grant-write-acp"`
}

// PutBucketCorsRequest is undocumented.
type PutBucketCorsRequest struct {
	Bucket            aws.StringValue    `xml:"Bucket"`
	CORSConfiguration *CORSConfiguration `xml:"CORSConfiguration"`
	ContentMD5        aws.StringValue    `xml:"Content-MD5"`
}

// PutBucketLifecycleRequest is undocumented.
type PutBucketLifecycleRequest struct {
	Bucket                 aws.StringValue         `xml:"Bucket"`
	ContentMD5             aws.StringValue         `xml:"Content-MD5"`
	LifecycleConfiguration *LifecycleConfiguration `xml:"LifecycleConfiguration"`
}

// PutBucketLoggingRequest is undocumented.
type PutBucketLoggingRequest struct {
	Bucket              aws.StringValue      `xml:"Bucket"`
	BucketLoggingStatus *BucketLoggingStatus `xml:"BucketLoggingStatus"`
	ContentMD5          aws.StringValue      `xml:"Content-MD5"`
}

// PutBucketNotificationRequest is undocumented.
type PutBucketNotificationRequest struct {
	Bucket                    aws.StringValue            `xml:"Bucket"`
	ContentMD5                aws.StringValue            `xml:"Content-MD5"`
	NotificationConfiguration *NotificationConfiguration `xml:"NotificationConfiguration"`
}

// PutBucketPolicyRequest is undocumented.
type PutBucketPolicyRequest struct {
	Bucket     aws.StringValue `xml:"Bucket"`
	ContentMD5 aws.StringValue `xml:"Content-MD5"`
	Policy     aws.StringValue `xml:"Policy"`
}

// PutBucketRequestPaymentRequest is undocumented.
type PutBucketRequestPaymentRequest struct {
	Bucket                      aws.StringValue              `xml:"Bucket"`
	ContentMD5                  aws.StringValue              `xml:"Content-MD5"`
	RequestPaymentConfiguration *RequestPaymentConfiguration `xml:"RequestPaymentConfiguration"`
}

// PutBucketTaggingRequest is undocumented.
type PutBucketTaggingRequest struct {
	Bucket     aws.StringValue `xml:"Bucket"`
	ContentMD5 aws.StringValue `xml:"Content-MD5"`
	Tagging    *Tagging        `xml:"Tagging"`
}

// PutBucketVersioningRequest is undocumented.
type PutBucketVersioningRequest struct {
	Bucket                  aws.StringValue          `xml:"Bucket"`
	ContentMD5              aws.StringValue          `xml:"Content-MD5"`
	MFA                     aws.StringValue          `xml:"x-amz-mfa"`
	VersioningConfiguration *VersioningConfiguration `xml:"VersioningConfiguration"`
}

// PutBucketWebsiteRequest is undocumented.
type PutBucketWebsiteRequest struct {
	Bucket               aws.StringValue       `xml:"Bucket"`
	ContentMD5           aws.StringValue       `xml:"Content-MD5"`
	WebsiteConfiguration *WebsiteConfiguration `xml:"WebsiteConfiguration"`
}

// PutObjectAclRequest is undocumented.
type PutObjectAclRequest struct {
	ACL                 aws.StringValue      `xml:"x-amz-acl"`
	AccessControlPolicy *AccessControlPolicy `xml:"AccessControlPolicy"`
	Bucket              aws.StringValue      `xml:"Bucket"`
	ContentMD5          aws.StringValue      `xml:"Content-MD5"`
	GrantFullControl    aws.StringValue      `xml:"x-amz-grant-full-control"`
	GrantRead           aws.StringValue      `xml:"x-amz-grant-read"`
	GrantReadACP        aws.StringValue      `xml:"x-amz-grant-read-acp"`
	GrantWrite          aws.StringValue      `xml:"x-amz-grant-write"`
	GrantWriteACP       aws.StringValue      `xml:"x-amz-grant-write-acp"`
	Key                 aws.StringValue      `xml:"Key"`
}

// PutObjectOutput is undocumented.
type PutObjectOutput struct {
	ETag                 aws.StringValue `xml:"ETag"`
	Expiration           time.Time       `xml:"x-amz-expiration"`
	SSECustomerAlgorithm aws.StringValue `xml:"x-amz-server-side-encryption-customer-algorithm"`
	SSECustomerKeyMD5    aws.StringValue `xml:"x-amz-server-side-encryption-customer-key-MD5"`
	SSEKMSKeyID          aws.StringValue `xml:"x-amz-server-side-encryption-aws-kms-key-id"`
	ServerSideEncryption aws.StringValue `xml:"x-amz-server-side-encryption"`
	VersionID            aws.StringValue `xml:"x-amz-version-id"`
}

// PutObjectRequest is undocumented.
type PutObjectRequest struct {
	ACL                     aws.StringValue   `xml:"x-amz-acl"`
	Body                    io.ReadCloser     `xml:"Body"`
	Bucket                  aws.StringValue   `xml:"Bucket"`
	CacheControl            aws.StringValue   `xml:"Cache-Control"`
	ContentDisposition      aws.StringValue   `xml:"Content-Disposition"`
	ContentEncoding         aws.StringValue   `xml:"Content-Encoding"`
	ContentLanguage         aws.StringValue   `xml:"Content-Language"`
	ContentLength           aws.IntegerValue  `xml:"Content-Length"`
	ContentMD5              aws.StringValue   `xml:"Content-MD5"`
	ContentType             aws.StringValue   `xml:"Content-Type"`
	Expires                 time.Time         `xml:"Expires"`
	GrantFullControl        aws.StringValue   `xml:"x-amz-grant-full-control"`
	GrantRead               aws.StringValue   `xml:"x-amz-grant-read"`
	GrantReadACP            aws.StringValue   `xml:"x-amz-grant-read-acp"`
	GrantWriteACP           aws.StringValue   `xml:"x-amz-grant-write-acp"`
	Key                     aws.StringValue   `xml:"Key"`
	Metadata                map[string]string `xml:"x-amz-meta-"`
	SSECustomerAlgorithm    aws.StringValue   `xml:"x-amz-server-side-encryption-customer-algorithm"`
	SSECustomerKey          aws.StringValue   `xml:"x-amz-server-side-encryption-customer-key"`
	SSECustomerKeyMD5       aws.StringValue   `xml:"x-amz-server-side-encryption-customer-key-MD5"`
	SSEKMSKeyID             aws.StringValue   `xml:"x-amz-server-side-encryption-aws-kms-key-id"`
	ServerSideEncryption    aws.StringValue   `xml:"x-amz-server-side-encryption"`
	StorageClass            aws.StringValue   `xml:"x-amz-storage-class"`
	WebsiteRedirectLocation aws.StringValue   `xml:"x-amz-website-redirect-location"`
}

// QueueConfiguration is undocumented.
type QueueConfiguration struct {
	Event  aws.StringValue `xml:"Event"`
	Events []string        `xml:"Event"`
	ID     aws.StringValue `xml:"Id"`
	Queue  aws.StringValue `xml:"Queue"`
}

// Redirect is undocumented.
type Redirect struct {
	HostName             aws.StringValue `xml:"HostName"`
	HTTPRedirectCode     aws.StringValue `xml:"HttpRedirectCode"`
	Protocol             aws.StringValue `xml:"Protocol"`
	ReplaceKeyPrefixWith aws.StringValue `xml:"ReplaceKeyPrefixWith"`
	ReplaceKeyWith       aws.StringValue `xml:"ReplaceKeyWith"`
}

// RedirectAllRequestsTo is undocumented.
type RedirectAllRequestsTo struct {
	HostName aws.StringValue `xml:"HostName"`
	Protocol aws.StringValue `xml:"Protocol"`
}

// RequestPaymentConfiguration is undocumented.
type RequestPaymentConfiguration struct {
	Payer aws.StringValue `xml:"Payer"`
}

// RestoreObjectRequest is undocumented.
type RestoreObjectRequest struct {
	Bucket         aws.StringValue `xml:"Bucket"`
	Key            aws.StringValue `xml:"Key"`
	RestoreRequest *RestoreRequest `xml:"RestoreRequest"`
	VersionID      aws.StringValue `xml:"versionId"`
}

// RestoreRequest is undocumented.
type RestoreRequest struct {
	Days aws.IntegerValue `xml:"Days"`
}

// RoutingRule is undocumented.
type RoutingRule struct {
	Condition *Condition `xml:"Condition"`
	Redirect  *Redirect  `xml:"Redirect"`
}

// Rule is undocumented.
type Rule struct {
	Expiration                  *LifecycleExpiration         `xml:"Expiration"`
	ID                          aws.StringValue              `xml:"ID"`
	NoncurrentVersionExpiration *NoncurrentVersionExpiration `xml:"NoncurrentVersionExpiration"`
	NoncurrentVersionTransition *NoncurrentVersionTransition `xml:"NoncurrentVersionTransition"`
	Prefix                      aws.StringValue              `xml:"Prefix"`
	Status                      aws.StringValue              `xml:"Status"`
	Transition                  *Transition                  `xml:"Transition"`
}

// Tag is undocumented.
type Tag struct {
	Key   aws.StringValue `xml:"Key"`
	Value aws.StringValue `xml:"Value"`
}

// Tagging is undocumented.
type Tagging struct {
	TagSet []Tag `xml:"TagSet"`
}

// TargetGrant is undocumented.
type TargetGrant struct {
	Grantee    *Grantee        `xml:"Grantee"`
	Permission aws.StringValue `xml:"Permission"`
}

// TopicConfiguration is undocumented.
type TopicConfiguration struct {
	Event  aws.StringValue `xml:"Event"`
	Events []string        `xml:"Event"`
	ID     aws.StringValue `xml:"Id"`
	Topic  aws.StringValue `xml:"Topic"`
}

// Transition is undocumented.
type Transition struct {
	Date         time.Time        `xml:"Date"`
	Days         aws.IntegerValue `xml:"Days"`
	StorageClass aws.StringValue  `xml:"StorageClass"`
}

// UploadPartCopyOutput is undocumented.
type UploadPartCopyOutput struct {
	CopyPartResult       *CopyPartResult `xml:"CopyPartResult"`
	CopySourceVersionID  aws.StringValue `xml:"x-amz-copy-source-version-id"`
	SSECustomerAlgorithm aws.StringValue `xml:"x-amz-server-side-encryption-customer-algorithm"`
	SSECustomerKeyMD5    aws.StringValue `xml:"x-amz-server-side-encryption-customer-key-MD5"`
	SSEKMSKeyID          aws.StringValue `xml:"x-amz-server-side-encryption-aws-kms-key-id"`
	ServerSideEncryption aws.StringValue `xml:"x-amz-server-side-encryption"`
}

// UploadPartCopyRequest is undocumented.
type UploadPartCopyRequest struct {
	Bucket                         aws.StringValue  `xml:"Bucket"`
	CopySource                     aws.StringValue  `xml:"x-amz-copy-source"`
	CopySourceIfMatch              aws.StringValue  `xml:"x-amz-copy-source-if-match"`
	CopySourceIfModifiedSince      time.Time        `xml:"x-amz-copy-source-if-modified-since"`
	CopySourceIfNoneMatch          aws.StringValue  `xml:"x-amz-copy-source-if-none-match"`
	CopySourceIfUnmodifiedSince    time.Time        `xml:"x-amz-copy-source-if-unmodified-since"`
	CopySourceRange                aws.StringValue  `xml:"x-amz-copy-source-range"`
	CopySourceSSECustomerAlgorithm aws.StringValue  `xml:"x-amz-copy-source-server-side-encryption-customer-algorithm"`
	CopySourceSSECustomerKey       aws.StringValue  `xml:"x-amz-copy-source-server-side-encryption-customer-key"`
	CopySourceSSECustomerKeyMD5    aws.StringValue  `xml:"x-amz-copy-source-server-side-encryption-customer-key-MD5"`
	Key                            aws.StringValue  `xml:"Key"`
	PartNumber                     aws.IntegerValue `xml:"partNumber"`
	SSECustomerAlgorithm           aws.StringValue  `xml:"x-amz-server-side-encryption-customer-algorithm"`
	SSECustomerKey                 aws.StringValue  `xml:"x-amz-server-side-encryption-customer-key"`
	SSECustomerKeyMD5              aws.StringValue  `xml:"x-amz-server-side-encryption-customer-key-MD5"`
	UploadID                       aws.StringValue  `xml:"uploadId"`
}

// UploadPartOutput is undocumented.
type UploadPartOutput struct {
	ETag                 aws.StringValue `xml:"ETag"`
	SSECustomerAlgorithm aws.StringValue `xml:"x-amz-server-side-encryption-customer-algorithm"`
	SSECustomerKeyMD5    aws.StringValue `xml:"x-amz-server-side-encryption-customer-key-MD5"`
	SSEKMSKeyID          aws.StringValue `xml:"x-amz-server-side-encryption-aws-kms-key-id"`
	ServerSideEncryption aws.StringValue `xml:"x-amz-server-side-encryption"`
}

// UploadPartRequest is undocumented.
type UploadPartRequest struct {
	Body                 io.ReadCloser    `xml:"Body"`
	Bucket               aws.StringValue  `xml:"Bucket"`
	ContentLength        aws.IntegerValue `xml:"Content-Length"`
	ContentMD5           aws.StringValue  `xml:"Content-MD5"`
	Key                  aws.StringValue  `xml:"Key"`
	PartNumber           aws.IntegerValue `xml:"partNumber"`
	SSECustomerAlgorithm aws.StringValue  `xml:"x-amz-server-side-encryption-customer-algorithm"`
	SSECustomerKey       aws.StringValue  `xml:"x-amz-server-side-encryption-customer-key"`
	SSECustomerKeyMD5    aws.StringValue  `xml:"x-amz-server-side-encryption-customer-key-MD5"`
	UploadID             aws.StringValue  `xml:"uploadId"`
}

// VersioningConfiguration is undocumented.
type VersioningConfiguration struct {
	MFADelete aws.StringValue `xml:"MfaDelete"`
	Status    aws.StringValue `xml:"Status"`
}

// WebsiteConfiguration is undocumented.
type WebsiteConfiguration struct {
	ErrorDocument         *ErrorDocument         `xml:"ErrorDocument"`
	IndexDocument         *IndexDocument         `xml:"IndexDocument"`
	RedirectAllRequestsTo *RedirectAllRequestsTo `xml:"RedirectAllRequestsTo"`
	RoutingRules          []RoutingRule          `xml:"RoutingRules"`
}

// avoid errors if the packages aren't referenced
var _ time.Time
var _ xml.Name

var _ bytes.Reader
var _ url.URL
var _ fmt.Stringer
var _ strings.Reader
var _ strconv.NumError
var _ = ioutil.Discard
